import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, c as create_slot, v as validate_each_argument, a as validate_slots, e as element, b as space, f as claim_element, g as children, h as detach_dev, j as claim_space, k as attr_dev, l as add_location, m as insert_dev, n as append_dev, o as listen_dev, p as null_to_empty, r as run_all, q as get_slot_context, t as get_slot_changes, u as transition_in, w as transition_out, x as destroy_each, y as toggle_class, z as add_render_callback, A as create_bidirectional_transition, B as noop, C as empty, D as group_outros, E as check_outros, F as create_in_transition, G as create_out_transition, H as assign, I as exclude_internal_props, J as set_attributes, K as get_spread_update, L as binding_callbacks, M as bind, N as create_component, O as query_selector_all, P as claim_component, Q as mount_component, R as add_flush_callback, T as destroy_component, U as text, V as claim_text } from './client.356e2a76.js';

/* node_modules/svelte-fullpage/src/Fullpage.svelte generated by Svelte v3.20.1 */

const file = "node_modules/svelte-fullpage/src/Fullpage.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[30] = list[i];
	child_ctx[32] = i;
	return child_ctx;
}

// (128:16) {#each sections as page,index}
function create_each_block(ctx) {
	let li;
	let button;
	let button_class_value;
	let t;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[24](/*index*/ ctx[32], ...args);
	}

	const block = {
		c: function create() {
			li = element("li");
			button = element("button");
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			button = claim_element(li_nodes, "BUTTON", { class: true });
			children(button).forEach(detach_dev);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", button_class_value = "svelte-fp-indicator-list-item-btn " + (/*activeSection*/ ctx[0] === /*index*/ ctx[32]
			? "svelte-fp-active"
			: "") + " svelte-1lli8rw");

			add_location(button, file, 129, 24, 4710);
			attr_dev(li, "class", "svelte-fp-indicator-list-item svelte-1lli8rw");
			add_location(li, file, 128, 20, 4643);
		},
		m: function mount(target, anchor, remount) {
			insert_dev(target, li, anchor);
			append_dev(li, button);
			append_dev(li, t);
			if (remount) dispose();
			dispose = listen_dev(button, "click", click_handler, false, false, false);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*activeSection*/ 1 && button_class_value !== (button_class_value = "svelte-fp-indicator-list-item-btn " + (/*activeSection*/ ctx[0] === /*index*/ ctx[32]
			? "svelte-fp-active"
			: "") + " svelte-1lli8rw")) {
				attr_dev(button, "class", button_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(128:16) {#each sections as page,index}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let div2;
	let div1;
	let t;
	let div0;
	let ul;
	let div2_class_value;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[22].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);
	let each_value = /*sections*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div2 = element("div");
			div1 = element("div");
			if (default_slot) default_slot.c();
			t = space();
			div0 = element("div");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { class: true, style: true });
			var div2_nodes = children(div2);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			if (default_slot) default_slot.l(div1_nodes);
			t = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			ul = claim_element(div0_nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "svelte-fp-indicator-list svelte-1lli8rw");
			add_location(ul, file, 126, 12, 4538);
			attr_dev(div0, "class", "svelte-fp-indicator svelte-1lli8rw");
			add_location(div0, file, 125, 8, 4492);
			attr_dev(div1, "class", "svelte-fp-container svelte-1lli8rw");
			add_location(div1, file, 123, 4, 4433);
			attr_dev(div2, "class", div2_class_value = "" + (null_to_empty(/*classes*/ ctx[3]) + " svelte-1lli8rw"));
			attr_dev(div2, "style", /*style*/ ctx[1]);
			add_location(div2, file, 121, 0, 4119);
		},
		m: function mount(target, anchor, remount) {
			insert_dev(target, div2, anchor);
			append_dev(div2, div1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append_dev(div1, t);
			append_dev(div1, div0);
			append_dev(div0, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			current = true;
			if (remount) run_all(dispose);

			dispose = [
				listen_dev(window, "keydown", /*keydown_handler*/ ctx[23], false, false, false),
				listen_dev(div2, "wheel", /*wheel_handler*/ ctx[25], false, false, false),
				listen_dev(div2, "touchstart", /*touchstart_handler*/ ctx[26], false, false, false),
				listen_dev(div2, "touchmove", /*touchmove_handler*/ ctx[27], false, false, false),
				listen_dev(div2, "drag", drag_handler, false, false, false),
				listen_dev(div2, "mousedown", /*mousedown_handler*/ ctx[28], false, false, false),
				listen_dev(div2, "mouseup", /*mouseup_handler*/ ctx[29], false, false, false)
			];
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 2097152) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[21], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, null));
				}
			}

			if (dirty[0] & /*activeSection, sections*/ 5) {
				each_value = /*sections*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty[0] & /*style*/ 2) {
				attr_dev(div2, "style", /*style*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (default_slot) default_slot.d(detaching);
			destroy_each(each_blocks, detaching);
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const drag_handler = () => {
	return false;
};

function instance($$self, $$props, $$invalidate) {
	let { class: defaultClasses = "" } = $$props;
	let { style = "" } = $$props;
	let { activeSection = 0 } = $$props;
	let { sections = [] } = $$props;
	let { transitionDuration = 500 } = $$props;
	let { arrows = false } = $$props;
	let { drag = false } = $$props;
	let dragStartPosition;
	let touchStartPosition;

	//extending exported classes with wrapper class
	let classes = `${defaultClasses} svelte-fp-wrapper`;

	let recentScroll = 0;

	//setting section visible
	let active = true;

	//function that handles scroll and sets scroll cooldown based on animation duration
	const handleScroll = event => {
		//getting direction of scroll, if negative, scroll up, if positive, scroll down
		let deltaY = event.deltaY;

		let timer = new Date().getTime();

		//if cooldown time is up, fullpage is scrollable again
		if (transitionDuration < timer - recentScroll) {
			recentScroll = timer;

			if (deltaY < 0) {
				scrollUp();
			} else if (deltaY > 0) {
				scrollDown();
			}
		}
	};

	//function that toggles visibility of active section
	const toggleActive = () => {
		active = !active;
	};

	//function that makes scroll up effect
	const scrollUp = async () => {
		// TODO: somehow fix animation
		if (activeSection > 0) {
			$$invalidate(0, activeSection--, activeSection);
		}
	};

	//function that makes scroll down effect
	const scrollDown = async () => {
		// TODO: somehow fix animation
		if (activeSection < sections.length - 1) {
			$$invalidate(0, activeSection++, activeSection);
		}
	};

	//function that handles arrow event
	const handleKey = event => {
		if (arrows) {
			switch (event.key) {
				case "ArrowDown":
					scrollDown();
					break;
				case "ArrowUp":
					scrollUp();
					break;
			}
		}
	};

	//function that handles drag start event
	const handleDragStart = event => {
		if (drag) {
			dragStartPosition = event.screenY;
		}
	}; //event.preventDefault();

	//function that handles drag end event
	const handleDragEnd = event => {
		if (drag) {
			const dragEndPosition = event.screenY;

			//console.log(`Start:${dragStartPosition}, End:${dragEndPosition}, vertical difference:${dragStartPosition-dragEndPosition}`);
			if (dragStartPosition - dragEndPosition > 100) {
				scrollDown();
			} else if (dragStartPosition - dragEndPosition < -100) {
				scrollUp();
			}
		}
	}; //event.preventDefault();

	//function that handles touch event
	const handleTouchStart = event => {
		//event.preventDefault();
		touchStartPosition = event.touches[0].screenY;
	};

	const handleTouchEnd = event => {
		//event.preventDefault();
		let timer = new Date().getTime();

		const touchEndPosition = event.touches[0].screenY;

		if (transitionDuration < timer - recentScroll) {
			if (touchStartPosition - touchEndPosition > 100) {
				scrollDown();
				recentScroll = timer;
			} else if (touchStartPosition - touchEndPosition < -100) {
				scrollUp();
				recentScroll = timer;
			}
		}
	};

	const writable_props = [
		"class",
		"style",
		"activeSection",
		"sections",
		"transitionDuration",
		"arrows",
		"drag"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Fullpage> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Fullpage", $$slots, ['default']);
	const keydown_handler = event => handleKey(event);
	const click_handler = index => $$invalidate(0, activeSection = index);
	const wheel_handler = event => handleScroll(event);
	const touchstart_handler = event => handleTouchStart(event);
	const touchmove_handler = event => handleTouchEnd(event);
	const mousedown_handler = event => handleDragStart(event);
	const mouseup_handler = event => handleDragEnd(event);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(10, defaultClasses = $$props.class);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("activeSection" in $$props) $$invalidate(0, activeSection = $$props.activeSection);
		if ("sections" in $$props) $$invalidate(2, sections = $$props.sections);
		if ("transitionDuration" in $$props) $$invalidate(11, transitionDuration = $$props.transitionDuration);
		if ("arrows" in $$props) $$invalidate(12, arrows = $$props.arrows);
		if ("drag" in $$props) $$invalidate(13, drag = $$props.drag);
		if ("$$scope" in $$props) $$invalidate(21, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		defaultClasses,
		style,
		activeSection,
		sections,
		transitionDuration,
		arrows,
		drag,
		dragStartPosition,
		touchStartPosition,
		classes,
		recentScroll,
		active,
		handleScroll,
		toggleActive,
		scrollUp,
		scrollDown,
		handleKey,
		handleDragStart,
		handleDragEnd,
		handleTouchStart,
		handleTouchEnd
	});

	$$self.$inject_state = $$props => {
		if ("defaultClasses" in $$props) $$invalidate(10, defaultClasses = $$props.defaultClasses);
		if ("style" in $$props) $$invalidate(1, style = $$props.style);
		if ("activeSection" in $$props) $$invalidate(0, activeSection = $$props.activeSection);
		if ("sections" in $$props) $$invalidate(2, sections = $$props.sections);
		if ("transitionDuration" in $$props) $$invalidate(11, transitionDuration = $$props.transitionDuration);
		if ("arrows" in $$props) $$invalidate(12, arrows = $$props.arrows);
		if ("drag" in $$props) $$invalidate(13, drag = $$props.drag);
		if ("dragStartPosition" in $$props) dragStartPosition = $$props.dragStartPosition;
		if ("touchStartPosition" in $$props) touchStartPosition = $$props.touchStartPosition;
		if ("classes" in $$props) $$invalidate(3, classes = $$props.classes);
		if ("recentScroll" in $$props) recentScroll = $$props.recentScroll;
		if ("active" in $$props) active = $$props.active;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		activeSection,
		style,
		sections,
		classes,
		handleScroll,
		handleKey,
		handleDragStart,
		handleDragEnd,
		handleTouchStart,
		handleTouchEnd,
		defaultClasses,
		transitionDuration,
		arrows,
		drag,
		dragStartPosition,
		touchStartPosition,
		recentScroll,
		active,
		toggleActive,
		scrollUp,
		scrollDown,
		$$scope,
		$$slots,
		keydown_handler,
		click_handler,
		wheel_handler,
		touchstart_handler,
		touchmove_handler,
		mousedown_handler,
		mouseup_handler
	];
}

class Fullpage extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				class: 10,
				style: 1,
				activeSection: 0,
				sections: 2,
				transitionDuration: 11,
				arrows: 12,
				drag: 13
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Fullpage",
			options,
			id: create_fragment.name
		});
	}

	get class() {
		throw new Error("<Fullpage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Fullpage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<Fullpage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<Fullpage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeSection() {
		throw new Error("<Fullpage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeSection(value) {
		throw new Error("<Fullpage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sections() {
		throw new Error("<Fullpage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sections(value) {
		throw new Error("<Fullpage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get transitionDuration() {
		throw new Error("<Fullpage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transitionDuration(value) {
		throw new Error("<Fullpage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get arrows() {
		throw new Error("<Fullpage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set arrows(value) {
		throw new Error("<Fullpage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get drag() {
		throw new Error("<Fullpage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set drag(value) {
		throw new Error("<Fullpage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function cubicOut(t) {
    const f = t - 1.0;
    return f * f * f + 1.0;
}

function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {
    const style = getComputedStyle(node);
    const target_opacity = +style.opacity;
    const transform = style.transform === 'none' ? '' : style.transform;
    const od = target_opacity * (1 - opacity);
    return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
    };
}
function slide(node, { delay = 0, duration = 400, easing = cubicOut }) {
    const style = getComputedStyle(node);
    const opacity = +style.opacity;
    const height = parseFloat(style.height);
    const padding_top = parseFloat(style.paddingTop);
    const padding_bottom = parseFloat(style.paddingBottom);
    const margin_top = parseFloat(style.marginTop);
    const margin_bottom = parseFloat(style.marginBottom);
    const border_top_width = parseFloat(style.borderTopWidth);
    const border_bottom_width = parseFloat(style.borderBottomWidth);
    return {
        delay,
        duration,
        easing,
        css: t => `overflow: hidden;` +
            `opacity: ${Math.min(t * 20, 1) * opacity};` +
            `height: ${t * height}px;` +
            `padding-top: ${t * padding_top}px;` +
            `padding-bottom: ${t * padding_bottom}px;` +
            `margin-top: ${t * margin_top}px;` +
            `margin-bottom: ${t * margin_bottom}px;` +
            `border-top-width: ${t * border_top_width}px;` +
            `border-bottom-width: ${t * border_bottom_width}px;`
    };
}

/* node_modules/svelte-fullpage/src/FullpageSection.svelte generated by Svelte v3.20.1 */
const file$1 = "node_modules/svelte-fullpage/src/FullpageSection.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[31] = list[i];
	child_ctx[33] = i;
	return child_ctx;
}

// (106:0) {#if sectionId === activeSection}
function create_if_block(ctx) {
	let section;
	let div;
	let t;
	let section_class_value;
	let section_transition;
	let current;
	let dispose;
	const default_slot_template = /*$$slots*/ ctx[24].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[23], null);
	const default_slot_or_fallback = default_slot || fallback_block(ctx);
	let if_block = /*slides*/ ctx[4][0] && create_if_block_1(ctx);

	const block = {
		c: function create() {
			section = element("section");
			div = element("div");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			section = claim_element(nodes, "SECTION", { class: true, style: true });
			var section_nodes = children(section);
			div = claim_element(section_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot_or_fallback) default_slot_or_fallback.l(div_nodes);
			div_nodes.forEach(detach_dev);
			t = claim_space(section_nodes);
			if (if_block) if_block.l(section_nodes);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-fp-container svelte-fp-flexbox-expand svelte-l4liqa");
			toggle_class(div, "svelte-fp-flexbox-center", /*center*/ ctx[5]);
			add_location(div, file$1, 109, 8, 3229);
			attr_dev(section, "class", section_class_value = "" + (null_to_empty(/*classes*/ ctx[7]) + " svelte-l4liqa"));
			attr_dev(section, "style", /*style*/ ctx[2]);
			add_location(section, file$1, 106, 4, 2903);
		},
		m: function mount(target, anchor, remount) {
			insert_dev(target, section, anchor);
			append_dev(section, div);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(div, null);
			}

			append_dev(section, t);
			if (if_block) if_block.m(section, null);
			current = true;
			if (remount) run_all(dispose);

			dispose = [
				listen_dev(section, "selectstart", /*handleSelect*/ ctx[8], false, false, false),
				listen_dev(section, "mousedown", /*mousedown_handler*/ ctx[27], false, false, false),
				listen_dev(section, "mouseup", /*mouseup_handler*/ ctx[28], false, false, false),
				listen_dev(section, "touchstart", /*touchstart_handler*/ ctx[29], false, false, false),
				listen_dev(section, "touchmove", /*touchmove_handler*/ ctx[30], false, false, false)
			];
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty[0] & /*$$scope*/ 8388608) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[23], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[23], dirty, null));
				}
			}

			if (dirty[0] & /*center*/ 32) {
				toggle_class(div, "svelte-fp-flexbox-center", /*center*/ ctx[5]);
			}

			if (/*slides*/ ctx[4][0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(section, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty[0] & /*classes*/ 128 && section_class_value !== (section_class_value = "" + (null_to_empty(/*classes*/ ctx[7]) + " svelte-l4liqa"))) {
				attr_dev(section, "class", section_class_value);
			}

			if (!current || dirty[0] & /*style*/ 4) {
				attr_dev(section, "style", /*style*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);

			add_render_callback(() => {
				if (!section_transition) section_transition = create_bidirectional_transition(section, slide, /*transition*/ ctx[6], true);
				section_transition.run(1);
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			if (!section_transition) section_transition = create_bidirectional_transition(section, slide, /*transition*/ ctx[6], false);
			section_transition.run(0);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			if (if_block) if_block.d();
			if (detaching && section_transition) section_transition.end();
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(106:0) {#if sectionId === activeSection}",
		ctx
	});

	return block;
}

// (111:18)              
function fallback_block(ctx) {
	const block = { c: noop, l: noop, m: noop, d: noop };

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block.name,
		type: "fallback",
		source: "(111:18)              ",
		ctx
	});

	return block;
}

// (114:8) {#if slides[0]}
function create_if_block_1(ctx) {
	let div;
	let ul;
	let each_value = /*slides*/ ctx[4];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = element("div");
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			ul = claim_element(div_nodes, "UL", { class: true });
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "svelte-fp-indicator-list-horizontal svelte-l4liqa");
			add_location(ul, file$1, 115, 16, 3479);
			attr_dev(div, "class", "svelte-fp-indicator-horizontal svelte-l4liqa");
			add_location(div, file$1, 114, 12, 3418);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*activeSlide, slides*/ 18) {
				each_value = /*slides*/ ctx[4];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(114:8) {#if slides[0]}",
		ctx
	});

	return block;
}

// (117:20) {#each slides as page,index}
function create_each_block$1(ctx) {
	let li;
	let button;
	let button_class_value;
	let t;
	let dispose;

	function click_handler(...args) {
		return /*click_handler*/ ctx[26](/*index*/ ctx[33], ...args);
	}

	const block = {
		c: function create() {
			li = element("li");
			button = element("button");
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			button = claim_element(li_nodes, "BUTTON", { class: true });
			children(button).forEach(detach_dev);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "class", button_class_value = "svelte-fp-indicator-list-item-btn " + (/*activeSlide*/ ctx[1] === /*index*/ ctx[33]
			? "svelte-fp-active"
			: "") + " svelte-l4liqa");

			add_location(button, file$1, 118, 28, 3672);
			attr_dev(li, "class", "svelte-fp-indicator-list-item svelte-l4liqa");
			add_location(li, file$1, 117, 24, 3601);
		},
		m: function mount(target, anchor, remount) {
			insert_dev(target, li, anchor);
			append_dev(li, button);
			append_dev(li, t);
			if (remount) dispose();
			dispose = listen_dev(button, "click", click_handler, false, false, false);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*activeSlide*/ 2 && button_class_value !== (button_class_value = "svelte-fp-indicator-list-item-btn " + (/*activeSlide*/ ctx[1] === /*index*/ ctx[33]
			? "svelte-fp-active"
			: "") + " svelte-l4liqa")) {
				attr_dev(button, "class", button_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(117:20) {#each slides as page,index}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let if_block_anchor;
	let current;
	let dispose;
	let if_block = /*sectionId*/ ctx[0] === /*activeSection*/ ctx[3] && create_if_block(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor, remount) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
			if (remount) dispose();
			dispose = listen_dev(window, "keydown", /*keydown_handler*/ ctx[25], false, false, false);
		},
		p: function update(ctx, dirty) {
			if (/*sectionId*/ ctx[0] === /*activeSection*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { class: defaultClasses = "" } = $$props;
	let { style = "" } = $$props;
	let { sectionId } = $$props;
	let { activeSection } = $$props;
	let { slides = [] } = $$props;
	let { activeSlide = false } = $$props;
	let { center = false } = $$props;
	let { arrows = false } = $$props;
	let { select = false } = $$props;
	let { transitionDuration = 500 } = $$props;
	let { transition = { duration: transitionDuration } } = $$props;
	sectionId = parseInt(sectionId);
	let dragStartPosition;
	let touchStartPosition;
	let recentSlide = 0;
	let classes = `${defaultClasses} svelte-fp-section svelte-fp-flexbox-center`;

	if (!select) {
		classes = `${classes} svelte-fp-unselectable`;
	}

	const handleSelect = () => {
		if (!select) {
			return false;
		}
	};

	const slideRight = () => {
		if (activeSlide < slides.length - 1) {
			$$invalidate(1, activeSlide++, activeSlide);
		} else {
			$$invalidate(1, activeSlide = 0);
		}
	};

	const slideLeft = () => {
		if (activeSlide > 0) {
			$$invalidate(1, activeSlide--, activeSlide);
		} else {
			$$invalidate(1, activeSlide = slides.length - 1);
		}
	};

	//function that handles arrow event
	const handleKey = event => {
		if (arrows) {
			switch (event.key) {
				case "ArrowLeft":
					slideLeft();
					break;
				case "ArrowRight":
					slideRight();
					break;
			}
		}
	};

	//function that handles drag start event
	const handleDragStart = event => {
		dragStartPosition = event.screenX;
	};

	//function that handles drag end event
	const handleDragEnd = event => {
		const dragEndPosition = event.screenX;

		if (dragStartPosition - dragEndPosition > 100) {
			slideRight();
		} else if (dragStartPosition - dragEndPosition < -100) {
			slideLeft();
		}
	};

	//function that handles touch event
	const handleTouchStart = event => {
		//event.preventDefault();
		touchStartPosition = event.touches[0].screenX;
	};

	const handleTouchEnd = event => {
		//event.preventDefault();
		let timer = new Date().getTime();

		const touchEndPosition = event.touches[0].screenX;

		if (transitionDuration < timer - recentSlide) {
			if (touchStartPosition - touchEndPosition > 100) {
				slideRight();
				recentSlide = timer;
			} else if (touchStartPosition - touchEndPosition < -100) {
				slideLeft();
				recentSlide = timer;
			}
		}
	};

	const writable_props = [
		"class",
		"style",
		"sectionId",
		"activeSection",
		"slides",
		"activeSlide",
		"center",
		"arrows",
		"select",
		"transitionDuration",
		"transition"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FullpageSection> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FullpageSection", $$slots, ['default']);
	const keydown_handler = event => handleKey(event);
	const click_handler = index => $$invalidate(1, activeSlide = index);
	const mousedown_handler = event => handleDragStart(event);
	const mouseup_handler = event => handleDragEnd(event);
	const touchstart_handler = event => handleTouchStart(event);
	const touchmove_handler = event => handleTouchEnd(event);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(14, defaultClasses = $$props.class);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
		if ("sectionId" in $$props) $$invalidate(0, sectionId = $$props.sectionId);
		if ("activeSection" in $$props) $$invalidate(3, activeSection = $$props.activeSection);
		if ("slides" in $$props) $$invalidate(4, slides = $$props.slides);
		if ("activeSlide" in $$props) $$invalidate(1, activeSlide = $$props.activeSlide);
		if ("center" in $$props) $$invalidate(5, center = $$props.center);
		if ("arrows" in $$props) $$invalidate(15, arrows = $$props.arrows);
		if ("select" in $$props) $$invalidate(16, select = $$props.select);
		if ("transitionDuration" in $$props) $$invalidate(17, transitionDuration = $$props.transitionDuration);
		if ("transition" in $$props) $$invalidate(6, transition = $$props.transition);
		if ("$$scope" in $$props) $$invalidate(23, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		slide,
		defaultClasses,
		style,
		sectionId,
		activeSection,
		slides,
		activeSlide,
		center,
		arrows,
		select,
		transitionDuration,
		transition,
		dragStartPosition,
		touchStartPosition,
		recentSlide,
		classes,
		handleSelect,
		slideRight,
		slideLeft,
		handleKey,
		handleDragStart,
		handleDragEnd,
		handleTouchStart,
		handleTouchEnd
	});

	$$self.$inject_state = $$props => {
		if ("defaultClasses" in $$props) $$invalidate(14, defaultClasses = $$props.defaultClasses);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
		if ("sectionId" in $$props) $$invalidate(0, sectionId = $$props.sectionId);
		if ("activeSection" in $$props) $$invalidate(3, activeSection = $$props.activeSection);
		if ("slides" in $$props) $$invalidate(4, slides = $$props.slides);
		if ("activeSlide" in $$props) $$invalidate(1, activeSlide = $$props.activeSlide);
		if ("center" in $$props) $$invalidate(5, center = $$props.center);
		if ("arrows" in $$props) $$invalidate(15, arrows = $$props.arrows);
		if ("select" in $$props) $$invalidate(16, select = $$props.select);
		if ("transitionDuration" in $$props) $$invalidate(17, transitionDuration = $$props.transitionDuration);
		if ("transition" in $$props) $$invalidate(6, transition = $$props.transition);
		if ("dragStartPosition" in $$props) dragStartPosition = $$props.dragStartPosition;
		if ("touchStartPosition" in $$props) touchStartPosition = $$props.touchStartPosition;
		if ("recentSlide" in $$props) recentSlide = $$props.recentSlide;
		if ("classes" in $$props) $$invalidate(7, classes = $$props.classes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		sectionId,
		activeSlide,
		style,
		activeSection,
		slides,
		center,
		transition,
		classes,
		handleSelect,
		handleKey,
		handleDragStart,
		handleDragEnd,
		handleTouchStart,
		handleTouchEnd,
		defaultClasses,
		arrows,
		select,
		transitionDuration,
		dragStartPosition,
		touchStartPosition,
		recentSlide,
		slideRight,
		slideLeft,
		$$scope,
		$$slots,
		keydown_handler,
		click_handler,
		mousedown_handler,
		mouseup_handler,
		touchstart_handler,
		touchmove_handler
	];
}

class FullpageSection extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal,
			{
				class: 14,
				style: 2,
				sectionId: 0,
				activeSection: 3,
				slides: 4,
				activeSlide: 1,
				center: 5,
				arrows: 15,
				select: 16,
				transitionDuration: 17,
				transition: 6
			},
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FullpageSection",
			options,
			id: create_fragment$1.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*sectionId*/ ctx[0] === undefined && !("sectionId" in props)) {
			console.warn("<FullpageSection> was created without expected prop 'sectionId'");
		}

		if (/*activeSection*/ ctx[3] === undefined && !("activeSection" in props)) {
			console.warn("<FullpageSection> was created without expected prop 'activeSection'");
		}
	}

	get class() {
		throw new Error("<FullpageSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<FullpageSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<FullpageSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<FullpageSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sectionId() {
		throw new Error("<FullpageSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sectionId(value) {
		throw new Error("<FullpageSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeSection() {
		throw new Error("<FullpageSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeSection(value) {
		throw new Error("<FullpageSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get slides() {
		throw new Error("<FullpageSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set slides(value) {
		throw new Error("<FullpageSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeSlide() {
		throw new Error("<FullpageSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeSlide(value) {
		throw new Error("<FullpageSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get center() {
		throw new Error("<FullpageSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set center(value) {
		throw new Error("<FullpageSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get arrows() {
		throw new Error("<FullpageSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set arrows(value) {
		throw new Error("<FullpageSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get select() {
		throw new Error("<FullpageSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set select(value) {
		throw new Error("<FullpageSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get transitionDuration() {
		throw new Error("<FullpageSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transitionDuration(value) {
		throw new Error("<FullpageSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get transition() {
		throw new Error("<FullpageSection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transition(value) {
		throw new Error("<FullpageSection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/svelte-fullpage/src/FullpageSlide.svelte generated by Svelte v3.20.1 */
const file$2 = "node_modules/svelte-fullpage/src/FullpageSlide.svelte";

// (22:0) {#if slideId === activeSlide}
function create_if_block$1(ctx) {
	let div;
	let div_class_value;
	let div_intro;
	let div_outro;
	let current;
	const default_slot_template = /*$$slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	const default_slot_or_fallback = default_slot || fallback_block$1(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			if (default_slot_or_fallback) default_slot_or_fallback.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "" + (null_to_empty(`${/*defaultClasses*/ ctx[1]} svelte-fp-content`) + " svelte-1jzpibp"));
			attr_dev(div, "style", /*style*/ ctx[2]);
			toggle_class(div, "svelte-fp-flexbox-center", /*center*/ ctx[4]);
			add_location(div, file$2, 22, 4, 466);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[7], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null));
				}
			}

			if (!current || dirty & /*defaultClasses*/ 2 && div_class_value !== (div_class_value = "" + (null_to_empty(`${/*defaultClasses*/ ctx[1]} svelte-fp-content`) + " svelte-1jzpibp"))) {
				attr_dev(div, "class", div_class_value);
			}

			if (!current || dirty & /*style*/ 4) {
				attr_dev(div, "style", /*style*/ ctx[2]);
			}

			if (dirty & /*defaultClasses, center*/ 18) {
				toggle_class(div, "svelte-fp-flexbox-center", /*center*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);

			add_render_callback(() => {
				if (div_outro) div_outro.end(1);
				if (!div_intro) div_intro = create_in_transition(div, fly, /*transitionIn*/ ctx[5]);
				div_intro.start();
			});

			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot_or_fallback, local);
			if (div_intro) div_intro.invalidate();
			div_outro = create_out_transition(div, fly, /*transitionOut*/ ctx[6]);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			if (detaching && div_outro) div_outro.end();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(22:0) {#if slideId === activeSlide}",
		ctx
	});

	return block;
}

// (24:14)          
function fallback_block$1(ctx) {
	const block = { c: noop, l: noop, m: noop, d: noop };

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: fallback_block$1.name,
		type: "fallback",
		source: "(24:14)          ",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*slideId*/ ctx[0] === /*activeSlide*/ ctx[3] && create_if_block$1(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*slideId*/ ctx[0] === /*activeSlide*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
					transition_in(if_block, 1);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { class: defaultClasses = "" } = $$props;
	let { style = "" } = $$props;
	let { slideId } = $$props;
	let { activeSlide } = $$props;
	let { center = false } = $$props;
	let { transitionIn = { duration: 250, x: -200 } } = $$props;
	let { transitionOut = { duration: 250, x: 200 } } = $$props;
	slideId = parseInt(slideId);

	const writable_props = [
		"class",
		"style",
		"slideId",
		"activeSlide",
		"center",
		"transitionIn",
		"transitionOut"
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FullpageSlide> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("FullpageSlide", $$slots, ['default']);

	$$self.$set = $$props => {
		if ("class" in $$props) $$invalidate(1, defaultClasses = $$props.class);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
		if ("slideId" in $$props) $$invalidate(0, slideId = $$props.slideId);
		if ("activeSlide" in $$props) $$invalidate(3, activeSlide = $$props.activeSlide);
		if ("center" in $$props) $$invalidate(4, center = $$props.center);
		if ("transitionIn" in $$props) $$invalidate(5, transitionIn = $$props.transitionIn);
		if ("transitionOut" in $$props) $$invalidate(6, transitionOut = $$props.transitionOut);
		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		fly,
		defaultClasses,
		style,
		slideId,
		activeSlide,
		center,
		transitionIn,
		transitionOut
	});

	$$self.$inject_state = $$props => {
		if ("defaultClasses" in $$props) $$invalidate(1, defaultClasses = $$props.defaultClasses);
		if ("style" in $$props) $$invalidate(2, style = $$props.style);
		if ("slideId" in $$props) $$invalidate(0, slideId = $$props.slideId);
		if ("activeSlide" in $$props) $$invalidate(3, activeSlide = $$props.activeSlide);
		if ("center" in $$props) $$invalidate(4, center = $$props.center);
		if ("transitionIn" in $$props) $$invalidate(5, transitionIn = $$props.transitionIn);
		if ("transitionOut" in $$props) $$invalidate(6, transitionOut = $$props.transitionOut);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		slideId,
		defaultClasses,
		style,
		activeSlide,
		center,
		transitionIn,
		transitionOut,
		$$scope,
		$$slots
	];
}

class FullpageSlide extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
			class: 1,
			style: 2,
			slideId: 0,
			activeSlide: 3,
			center: 4,
			transitionIn: 5,
			transitionOut: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FullpageSlide",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*slideId*/ ctx[0] === undefined && !("slideId" in props)) {
			console.warn("<FullpageSlide> was created without expected prop 'slideId'");
		}

		if (/*activeSlide*/ ctx[3] === undefined && !("activeSlide" in props)) {
			console.warn("<FullpageSlide> was created without expected prop 'activeSlide'");
		}
	}

	get class() {
		throw new Error("<FullpageSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<FullpageSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get style() {
		throw new Error("<FullpageSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set style(value) {
		throw new Error("<FullpageSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get slideId() {
		throw new Error("<FullpageSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set slideId(value) {
		throw new Error("<FullpageSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get activeSlide() {
		throw new Error("<FullpageSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set activeSlide(value) {
		throw new Error("<FullpageSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get center() {
		throw new Error("<FullpageSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set center(value) {
		throw new Error("<FullpageSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get transitionIn() {
		throw new Error("<FullpageSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transitionIn(value) {
		throw new Error("<FullpageSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get transitionOut() {
		throw new Error("<FullpageSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set transitionOut(value) {
		throw new Error("<FullpageSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function toVal(mix) {
	var k, y, str='';
	if (mix) {
		if (typeof mix === 'object') {
			if (Array.isArray(mix)) {
				for (k=0; k < mix.length; k++) {
					if (mix[k] && (y = toVal(mix[k]))) {
						str && (str += ' ');
						str += y;
					}
				}
			} else {
				for (k in mix) {
					if (mix[k] && (y = toVal(k))) {
						str && (str += ' ');
						str += y;
					}
				}
			}
		} else if (typeof mix !== 'boolean' && !mix.call) {
			str && (str += ' ');
			str += mix;
		}
	}
	return str;
}

function clsx () {
	var i=0, x, str='';
	while (i < arguments.length) {
		if (x = toVal(arguments[i++])) {
			str && (str += ' ');
			str += x;
		}
	}
	return str;
}

function isObject(value) {
  const type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

function getColumnSizeClass(isXs, colWidth, colSize) {
  if (colSize === true || colSize === '') {
    return isXs ? 'col' : `col-${colWidth}`;
  } else if (colSize === 'auto') {
    return isXs ? 'col-auto' : `col-${colWidth}-auto`;
  }

  return isXs ? `col-${colSize}` : `col-${colWidth}-${colSize}`;
}

function clean($$props) {
  const rest = {};
  for (const key of Object.keys($$props)) {
    if (key !== "children" && key !== "$$scope" && key !== "$$slots") {
      rest[key] = $$props[key];
    }
  }
  return rest;
}

/* node_modules/sveltestrap/src/Container.svelte generated by Svelte v3.20.1 */
const file$3 = "node_modules/sveltestrap/src/Container.svelte";

function create_fragment$3(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);
	let div_levels = [/*props*/ ctx[2], { id: /*id*/ ctx[0] }, { class: /*classes*/ ctx[1] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(div, div_data);
			add_location(div, file$3, 14, 0, 295);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[6], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null));
				}
			}

			set_attributes(div, get_spread_update(div_levels, [
				dirty & /*props*/ 4 && /*props*/ ctx[2],
				dirty & /*id*/ 1 && { id: /*id*/ ctx[0] },
				dirty & /*classes*/ 2 && { class: /*classes*/ ctx[1] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let { class: className = "" } = $$props;
	let { fluid = false } = $$props;
	let { id = "" } = $$props;
	const props = clean($$props);
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Container", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("fluid" in $$new_props) $$invalidate(4, fluid = $$new_props.fluid);
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		clsx,
		clean,
		className,
		fluid,
		id,
		props,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("fluid" in $$props) $$invalidate(4, fluid = $$new_props.fluid);
		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, fluid*/ 24) {
			 $$invalidate(1, classes = clsx(className, fluid ? "container-fluid" : "container"));
		}
	};

	$$props = exclude_internal_props($$props);
	return [id, classes, props, className, fluid, $$props, $$scope, $$slots];
}

class Container extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { class: 3, fluid: 4, id: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Container",
			options,
			id: create_fragment$3.name
		});
	}

	get class() {
		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fluid() {
		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fluid(value) {
		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Container>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Container>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Row.svelte generated by Svelte v3.20.1 */
const file$4 = "node_modules/sveltestrap/src/Row.svelte";

function create_fragment$4(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	let div_levels = [/*props*/ ctx[2], { id: /*id*/ ctx[0] }, { class: /*classes*/ ctx[1] }];
	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(div, div_data);
			add_location(div, file$4, 19, 0, 361);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 128) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[7], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null));
				}
			}

			set_attributes(div, get_spread_update(div_levels, [
				dirty & /*props*/ 4 && /*props*/ ctx[2],
				dirty & /*id*/ 1 && { id: /*id*/ ctx[0] },
				dirty & /*classes*/ 2 && { class: /*classes*/ ctx[1] }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let { class: className = "" } = $$props;
	let { noGutters = false } = $$props;
	let { form = false } = $$props;
	let { id = "" } = $$props;
	const props = clean($$props);
	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Row", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("noGutters" in $$new_props) $$invalidate(4, noGutters = $$new_props.noGutters);
		if ("form" in $$new_props) $$invalidate(5, form = $$new_props.form);
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		clsx,
		clean,
		className,
		noGutters,
		form,
		id,
		props,
		classes
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("noGutters" in $$props) $$invalidate(4, noGutters = $$new_props.noGutters);
		if ("form" in $$props) $$invalidate(5, form = $$new_props.form);
		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
		if ("classes" in $$props) $$invalidate(1, classes = $$new_props.classes);
	};

	let classes;

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*className, noGutters, form*/ 56) {
			 $$invalidate(1, classes = clsx(className, noGutters ? "no-gutters" : null, form ? "form-row" : "row"));
		}
	};

	$$props = exclude_internal_props($$props);
	return [id, classes, props, className, noGutters, form, $$props, $$scope, $$slots];
}

class Row extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { class: 3, noGutters: 4, form: 5, id: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Row",
			options,
			id: create_fragment$4.name
		});
	}

	get class() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get noGutters() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set noGutters(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get form() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set form(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* node_modules/sveltestrap/src/Col.svelte generated by Svelte v3.20.1 */
const file$5 = "node_modules/sveltestrap/src/Col.svelte";

function create_fragment$5(ctx) {
	let div;
	let current;
	const default_slot_template = /*$$slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

	let div_levels = [
		/*props*/ ctx[1],
		{ id: /*id*/ ctx[0] },
		{ class: /*colClasses*/ ctx[2].join(" ") }
	];

	let div_data = {};

	for (let i = 0; i < div_levels.length; i += 1) {
		div_data = assign(div_data, div_levels[i]);
	}

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_attributes(div, div_data);
			add_location(div, file$5, 51, 0, 1305);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && dirty & /*$$scope*/ 64) {
					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[6], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null));
				}
			}

			set_attributes(div, get_spread_update(div_levels, [
				dirty & /*props*/ 2 && /*props*/ ctx[1],
				dirty & /*id*/ 1 && { id: /*id*/ ctx[0] },
				dirty & /*colClasses*/ 4 && { class: /*colClasses*/ ctx[2].join(" ") }
			]));
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let { class: className = "" } = $$props;
	let { id = "" } = $$props;
	const props = clean($$props);
	const colClasses = [];
	const widths = ["xs", "sm", "md", "lg", "xl"];

	widths.forEach(colWidth => {
		const columnProp = $$props[colWidth];

		if (!columnProp && columnProp !== "") {
			return; //no value for this width
		}

		const isXs = colWidth === "xs";

		if (isObject(columnProp)) {
			const colSizeInterfix = isXs ? "-" : `-${colWidth}-`;
			const colClass = getColumnSizeClass(isXs, colWidth, columnProp.size);

			if (columnProp.size || columnProp.size === "") {
				colClasses.push(colClass);
			}

			if (columnProp.push) {
				colClasses.push(`push${colSizeInterfix}${columnProp.push}`);
			}

			if (columnProp.pull) {
				colClasses.push(`pull${colSizeInterfix}${columnProp.pull}`);
			}

			if (columnProp.offset) {
				colClasses.push(`offset${colSizeInterfix}${columnProp.offset}`);
			}
		} else {
			colClasses.push(getColumnSizeClass(isXs, colWidth, columnProp));
		}
	});

	if (!colClasses.length) {
		colClasses.push("col");
	}

	if (className) {
		colClasses.push(className);
	}

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Col", $$slots, ['default']);

	$$self.$set = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
	};

	$$self.$capture_state = () => ({
		clean,
		getColumnSizeClass,
		isObject,
		className,
		id,
		props,
		colClasses,
		widths
	});

	$$self.$inject_state = $$new_props => {
		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$props = exclude_internal_props($$props);
	return [id, props, colClasses, className, widths, $$props, $$scope, $$slots];
}

class Col extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$5, create_fragment$5, safe_not_equal, { class: 3, id: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Col",
			options,
			id: create_fragment$5.name
		});
	}

	get class() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set class(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get id() {
		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set id(value) {
		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/index.svelte generated by Svelte v3.20.1 */
const file$6 = "src/routes/index.svelte";

// (38:4) <Col>
function create_default_slot_10(ctx) {
	let h1;
	let t0;
	let t1;
	let p;
	let t2;

	const block = {
		c: function create() {
			h1 = element("h1");
			t0 = text("Svelte Fullpage");
			t1 = space();
			p = element("p");
			t2 = text("This page is made using svelte-fullpage component, try to scroll, drag with mouse or swipe vertical with finger.");
			this.h();
		},
		l: function claim(nodes) {
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t0 = claim_text(h1_nodes, "Svelte Fullpage");
			h1_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t2 = claim_text(p_nodes, "This page is made using svelte-fullpage component, try to scroll, drag with mouse or swipe vertical with finger.");
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file$6, 38, 5, 1075);
			add_location(p, file$6, 41, 5, 1118);
		},
		m: function mount(target, anchor) {
			insert_dev(target, h1, anchor);
			append_dev(h1, t0);
			insert_dev(target, t1, anchor);
			insert_dev(target, p, anchor);
			append_dev(p, t2);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_10.name,
		type: "slot",
		source: "(38:4) <Col>",
		ctx
	});

	return block;
}

// (37:3) <Row>
function create_default_slot_9(ctx) {
	let current;

	const col = new Col({
			props: {
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(col.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(col.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(col, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const col_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				col_changes.$$scope = { dirty, ctx };
			}

			col.$set(col_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(col.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(col.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(col, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_9.name,
		type: "slot",
		source: "(37:3) <Row>",
		ctx
	});

	return block;
}

// (36:2) <Container class="text-center">
function create_default_slot_8(ctx) {
	let current;

	const row = new Row({
			props: {
				$$slots: { default: [create_default_slot_9] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(row.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(row.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(row, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const row_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				row_changes.$$scope = { dirty, ctx };
			}

			row.$set(row_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(row.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(row.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(row, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_8.name,
		type: "slot",
		source: "(36:2) <Container class=\\\"text-center\\\">",
		ctx
	});

	return block;
}

// (35:1) <FullpageSection sectionId="0" bind:activeSection center>
function create_default_slot_7(ctx) {
	let current;

	const container = new Container({
			props: {
				class: "text-center",
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(container.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(container.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(container, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const container_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				container_changes.$$scope = { dirty, ctx };
			}

			container.$set(container_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(container.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(container.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(container, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_7.name,
		type: "slot",
		source: "(35:1) <FullpageSection sectionId=\\\"0\\\" bind:activeSection center>",
		ctx
	});

	return block;
}

// (50:2) <FullpageSlide slideId="0" bind:activeSlide center>
function create_default_slot_6(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("a");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			t = claim_text(div_nodes, "a");
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$6, 50, 3, 1471);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_6.name,
		type: "slot",
		source: "(50:2) <FullpageSlide slideId=\\\"0\\\" bind:activeSlide center>",
		ctx
	});

	return block;
}

// (54:2) <FullpageSlide slideId="1" bind:activeSlide class="bg-danger" center>
function create_default_slot_5(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("a");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			t = claim_text(div_nodes, "a");
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$6, 54, 3, 1582);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_5.name,
		type: "slot",
		source: "(54:2) <FullpageSlide slideId=\\\"1\\\" bind:activeSlide class=\\\"bg-danger\\\" center>",
		ctx
	});

	return block;
}

// (58:2) <FullpageSlide slideId="2" bind:activeSlide center>
function create_default_slot_4(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("a");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			t = claim_text(div_nodes, "a");
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$6, 58, 3, 1675);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_4.name,
		type: "slot",
		source: "(58:2) <FullpageSlide slideId=\\\"2\\\" bind:activeSlide center>",
		ctx
	});

	return block;
}

// (49:1) <FullpageSection sectionId="1" bind:activeSection bind:activeSlide {slides} class="bg-info" arrows cente>
function create_default_slot_3(ctx) {
	let updating_activeSlide;
	let t0;
	let updating_activeSlide_1;
	let t1;
	let updating_activeSlide_2;
	let current;

	function fullpageslide0_activeSlide_binding(value) {
		/*fullpageslide0_activeSlide_binding*/ ctx[5].call(null, value);
	}

	let fullpageslide0_props = {
		slideId: "0",
		center: true,
		$$slots: { default: [create_default_slot_6] },
		$$scope: { ctx }
	};

	if (/*activeSlide*/ ctx[1] !== void 0) {
		fullpageslide0_props.activeSlide = /*activeSlide*/ ctx[1];
	}

	const fullpageslide0 = new FullpageSlide({
			props: fullpageslide0_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(fullpageslide0, "activeSlide", fullpageslide0_activeSlide_binding));

	function fullpageslide1_activeSlide_binding(value) {
		/*fullpageslide1_activeSlide_binding*/ ctx[6].call(null, value);
	}

	let fullpageslide1_props = {
		slideId: "1",
		class: "bg-danger",
		center: true,
		$$slots: { default: [create_default_slot_5] },
		$$scope: { ctx }
	};

	if (/*activeSlide*/ ctx[1] !== void 0) {
		fullpageslide1_props.activeSlide = /*activeSlide*/ ctx[1];
	}

	const fullpageslide1 = new FullpageSlide({
			props: fullpageslide1_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(fullpageslide1, "activeSlide", fullpageslide1_activeSlide_binding));

	function fullpageslide2_activeSlide_binding(value) {
		/*fullpageslide2_activeSlide_binding*/ ctx[7].call(null, value);
	}

	let fullpageslide2_props = {
		slideId: "2",
		center: true,
		$$slots: { default: [create_default_slot_4] },
		$$scope: { ctx }
	};

	if (/*activeSlide*/ ctx[1] !== void 0) {
		fullpageslide2_props.activeSlide = /*activeSlide*/ ctx[1];
	}

	const fullpageslide2 = new FullpageSlide({
			props: fullpageslide2_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(fullpageslide2, "activeSlide", fullpageslide2_activeSlide_binding));

	const block = {
		c: function create() {
			create_component(fullpageslide0.$$.fragment);
			t0 = space();
			create_component(fullpageslide1.$$.fragment);
			t1 = space();
			create_component(fullpageslide2.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(fullpageslide0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(fullpageslide1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(fullpageslide2.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(fullpageslide0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(fullpageslide1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(fullpageslide2, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const fullpageslide0_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				fullpageslide0_changes.$$scope = { dirty, ctx };
			}

			if (!updating_activeSlide && dirty & /*activeSlide*/ 2) {
				updating_activeSlide = true;
				fullpageslide0_changes.activeSlide = /*activeSlide*/ ctx[1];
				add_flush_callback(() => updating_activeSlide = false);
			}

			fullpageslide0.$set(fullpageslide0_changes);
			const fullpageslide1_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				fullpageslide1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_activeSlide_1 && dirty & /*activeSlide*/ 2) {
				updating_activeSlide_1 = true;
				fullpageslide1_changes.activeSlide = /*activeSlide*/ ctx[1];
				add_flush_callback(() => updating_activeSlide_1 = false);
			}

			fullpageslide1.$set(fullpageslide1_changes);
			const fullpageslide2_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				fullpageslide2_changes.$$scope = { dirty, ctx };
			}

			if (!updating_activeSlide_2 && dirty & /*activeSlide*/ 2) {
				updating_activeSlide_2 = true;
				fullpageslide2_changes.activeSlide = /*activeSlide*/ ctx[1];
				add_flush_callback(() => updating_activeSlide_2 = false);
			}

			fullpageslide2.$set(fullpageslide2_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fullpageslide0.$$.fragment, local);
			transition_in(fullpageslide1.$$.fragment, local);
			transition_in(fullpageslide2.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fullpageslide0.$$.fragment, local);
			transition_out(fullpageslide1.$$.fragment, local);
			transition_out(fullpageslide2.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(fullpageslide0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(fullpageslide1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(fullpageslide2, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(49:1) <FullpageSection sectionId=\\\"1\\\" bind:activeSection bind:activeSlide {slides} class=\\\"bg-info\\\" arrows cente>",
		ctx
	});

	return block;
}

// (63:1) <FullpageSection sectionId="2" bind:activeSection center>
function create_default_slot_2(ctx) {
	let embed;
	let embed_src_value;

	const block = {
		c: function create() {
			embed = element("embed");
			this.h();
		},
		l: function claim(nodes) {
			embed = claim_element(nodes, "EMBED", { src: true, type: true });
			this.h();
		},
		h: function hydrate() {
			if (embed.src !== (embed_src_value = "")) attr_dev(embed, "src", embed_src_value);
			attr_dev(embed, "type", "");
			add_location(embed, file$6, 63, 2, 1792);
		},
		m: function mount(target, anchor) {
			insert_dev(target, embed, anchor);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(embed);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(63:1) <FullpageSection sectionId=\\\"2\\\" bind:activeSection center>",
		ctx
	});

	return block;
}

// (66:1) <FullpageSection sectionId="3" bind:activeSection class="bg-warning" center>
function create_default_slot_1(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text("a");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			t = claim_text(div_nodes, "a");
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$6, 66, 2, 1915);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(66:1) <FullpageSection sectionId=\\\"3\\\" bind:activeSection class=\\\"bg-warning\\\" center>",
		ctx
	});

	return block;
}

// (34:0) <Fullpage bind:activeSection {sections} arrows drag>
function create_default_slot(ctx) {
	let updating_activeSection;
	let t0;
	let updating_activeSection_1;
	let updating_activeSlide;
	let t1;
	let updating_activeSection_2;
	let t2;
	let updating_activeSection_3;
	let current;

	function fullpagesection0_activeSection_binding(value) {
		/*fullpagesection0_activeSection_binding*/ ctx[4].call(null, value);
	}

	let fullpagesection0_props = {
		sectionId: "0",
		center: true,
		$$slots: { default: [create_default_slot_7] },
		$$scope: { ctx }
	};

	if (/*activeSection*/ ctx[0] !== void 0) {
		fullpagesection0_props.activeSection = /*activeSection*/ ctx[0];
	}

	const fullpagesection0 = new FullpageSection({
			props: fullpagesection0_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(fullpagesection0, "activeSection", fullpagesection0_activeSection_binding));

	function fullpagesection1_activeSection_binding(value) {
		/*fullpagesection1_activeSection_binding*/ ctx[8].call(null, value);
	}

	function fullpagesection1_activeSlide_binding(value) {
		/*fullpagesection1_activeSlide_binding*/ ctx[9].call(null, value);
	}

	let fullpagesection1_props = {
		sectionId: "1",
		slides: /*slides*/ ctx[3],
		class: "bg-info",
		arrows: true,
		cente: true,
		$$slots: { default: [create_default_slot_3] },
		$$scope: { ctx }
	};

	if (/*activeSection*/ ctx[0] !== void 0) {
		fullpagesection1_props.activeSection = /*activeSection*/ ctx[0];
	}

	if (/*activeSlide*/ ctx[1] !== void 0) {
		fullpagesection1_props.activeSlide = /*activeSlide*/ ctx[1];
	}

	const fullpagesection1 = new FullpageSection({
			props: fullpagesection1_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(fullpagesection1, "activeSection", fullpagesection1_activeSection_binding));
	binding_callbacks.push(() => bind(fullpagesection1, "activeSlide", fullpagesection1_activeSlide_binding));

	function fullpagesection2_activeSection_binding(value) {
		/*fullpagesection2_activeSection_binding*/ ctx[10].call(null, value);
	}

	let fullpagesection2_props = {
		sectionId: "2",
		center: true,
		$$slots: { default: [create_default_slot_2] },
		$$scope: { ctx }
	};

	if (/*activeSection*/ ctx[0] !== void 0) {
		fullpagesection2_props.activeSection = /*activeSection*/ ctx[0];
	}

	const fullpagesection2 = new FullpageSection({
			props: fullpagesection2_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(fullpagesection2, "activeSection", fullpagesection2_activeSection_binding));

	function fullpagesection3_activeSection_binding(value) {
		/*fullpagesection3_activeSection_binding*/ ctx[11].call(null, value);
	}

	let fullpagesection3_props = {
		sectionId: "3",
		class: "bg-warning",
		center: true,
		$$slots: { default: [create_default_slot_1] },
		$$scope: { ctx }
	};

	if (/*activeSection*/ ctx[0] !== void 0) {
		fullpagesection3_props.activeSection = /*activeSection*/ ctx[0];
	}

	const fullpagesection3 = new FullpageSection({
			props: fullpagesection3_props,
			$$inline: true
		});

	binding_callbacks.push(() => bind(fullpagesection3, "activeSection", fullpagesection3_activeSection_binding));

	const block = {
		c: function create() {
			create_component(fullpagesection0.$$.fragment);
			t0 = space();
			create_component(fullpagesection1.$$.fragment);
			t1 = space();
			create_component(fullpagesection2.$$.fragment);
			t2 = space();
			create_component(fullpagesection3.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(fullpagesection0.$$.fragment, nodes);
			t0 = claim_space(nodes);
			claim_component(fullpagesection1.$$.fragment, nodes);
			t1 = claim_space(nodes);
			claim_component(fullpagesection2.$$.fragment, nodes);
			t2 = claim_space(nodes);
			claim_component(fullpagesection3.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(fullpagesection0, target, anchor);
			insert_dev(target, t0, anchor);
			mount_component(fullpagesection1, target, anchor);
			insert_dev(target, t1, anchor);
			mount_component(fullpagesection2, target, anchor);
			insert_dev(target, t2, anchor);
			mount_component(fullpagesection3, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const fullpagesection0_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				fullpagesection0_changes.$$scope = { dirty, ctx };
			}

			if (!updating_activeSection && dirty & /*activeSection*/ 1) {
				updating_activeSection = true;
				fullpagesection0_changes.activeSection = /*activeSection*/ ctx[0];
				add_flush_callback(() => updating_activeSection = false);
			}

			fullpagesection0.$set(fullpagesection0_changes);
			const fullpagesection1_changes = {};

			if (dirty & /*$$scope, activeSlide*/ 8194) {
				fullpagesection1_changes.$$scope = { dirty, ctx };
			}

			if (!updating_activeSection_1 && dirty & /*activeSection*/ 1) {
				updating_activeSection_1 = true;
				fullpagesection1_changes.activeSection = /*activeSection*/ ctx[0];
				add_flush_callback(() => updating_activeSection_1 = false);
			}

			if (!updating_activeSlide && dirty & /*activeSlide*/ 2) {
				updating_activeSlide = true;
				fullpagesection1_changes.activeSlide = /*activeSlide*/ ctx[1];
				add_flush_callback(() => updating_activeSlide = false);
			}

			fullpagesection1.$set(fullpagesection1_changes);
			const fullpagesection2_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				fullpagesection2_changes.$$scope = { dirty, ctx };
			}

			if (!updating_activeSection_2 && dirty & /*activeSection*/ 1) {
				updating_activeSection_2 = true;
				fullpagesection2_changes.activeSection = /*activeSection*/ ctx[0];
				add_flush_callback(() => updating_activeSection_2 = false);
			}

			fullpagesection2.$set(fullpagesection2_changes);
			const fullpagesection3_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				fullpagesection3_changes.$$scope = { dirty, ctx };
			}

			if (!updating_activeSection_3 && dirty & /*activeSection*/ 1) {
				updating_activeSection_3 = true;
				fullpagesection3_changes.activeSection = /*activeSection*/ ctx[0];
				add_flush_callback(() => updating_activeSection_3 = false);
			}

			fullpagesection3.$set(fullpagesection3_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fullpagesection0.$$.fragment, local);
			transition_in(fullpagesection1.$$.fragment, local);
			transition_in(fullpagesection2.$$.fragment, local);
			transition_in(fullpagesection3.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fullpagesection0.$$.fragment, local);
			transition_out(fullpagesection1.$$.fragment, local);
			transition_out(fullpagesection2.$$.fragment, local);
			transition_out(fullpagesection3.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(fullpagesection0, detaching);
			if (detaching) detach_dev(t0);
			destroy_component(fullpagesection1, detaching);
			if (detaching) detach_dev(t1);
			destroy_component(fullpagesection2, detaching);
			if (detaching) detach_dev(t2);
			destroy_component(fullpagesection3, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(34:0) <Fullpage bind:activeSection {sections} arrows drag>",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let t;
	let updating_activeSection;
	let current;

	function fullpage_activeSection_binding(value) {
		/*fullpage_activeSection_binding*/ ctx[12].call(null, value);
	}

	let fullpage_props = {
		sections: /*sections*/ ctx[2],
		arrows: true,
		drag: true,
		$$slots: { default: [create_default_slot] },
		$$scope: { ctx }
	};

	if (/*activeSection*/ ctx[0] !== void 0) {
		fullpage_props.activeSection = /*activeSection*/ ctx[0];
	}

	const fullpage = new Fullpage({ props: fullpage_props, $$inline: true });
	binding_callbacks.push(() => bind(fullpage, "activeSection", fullpage_activeSection_binding));

	const block = {
		c: function create() {
			t = space();
			create_component(fullpage.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all("[data-svelte=\"svelte-lm3wds\"]", document.head);
			head_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			claim_component(fullpage.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			document.title = "Svelte-fullpage";
		},
		m: function mount(target, anchor) {
			insert_dev(target, t, anchor);
			mount_component(fullpage, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const fullpage_changes = {};

			if (dirty & /*$$scope, activeSection, activeSlide*/ 8195) {
				fullpage_changes.$$scope = { dirty, ctx };
			}

			if (!updating_activeSection && dirty & /*activeSection*/ 1) {
				updating_activeSection = true;
				fullpage_changes.activeSection = /*activeSection*/ ctx[0];
				add_flush_callback(() => updating_activeSection = false);
			}

			fullpage.$set(fullpage_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fullpage.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fullpage.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			destroy_component(fullpage, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	const sections = ["Svelte Fullpage", "Features", "GitHub", "Future"];

	//Have to set to 0 (or section you wish to display as default), otherwise section will not display
	let activeSection = 0;

	//Same mechanics as in sections
	const slides = ["slides", "arrows", "drag"];

	//Also has to be 0 or specific id of slide
	let activeSlide = 0;

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Routes> was created with unknown prop '${key}'`);
	});

	let { $$slots = {}, $$scope } = $$props;
	validate_slots("Routes", $$slots, []);

	function fullpagesection0_activeSection_binding(value) {
		activeSection = value;
		$$invalidate(0, activeSection);
	}

	function fullpageslide0_activeSlide_binding(value) {
		activeSlide = value;
		$$invalidate(1, activeSlide);
	}

	function fullpageslide1_activeSlide_binding(value) {
		activeSlide = value;
		$$invalidate(1, activeSlide);
	}

	function fullpageslide2_activeSlide_binding(value) {
		activeSlide = value;
		$$invalidate(1, activeSlide);
	}

	function fullpagesection1_activeSection_binding(value) {
		activeSection = value;
		$$invalidate(0, activeSection);
	}

	function fullpagesection1_activeSlide_binding(value) {
		activeSlide = value;
		$$invalidate(1, activeSlide);
	}

	function fullpagesection2_activeSection_binding(value) {
		activeSection = value;
		$$invalidate(0, activeSection);
	}

	function fullpagesection3_activeSection_binding(value) {
		activeSection = value;
		$$invalidate(0, activeSection);
	}

	function fullpage_activeSection_binding(value) {
		activeSection = value;
		$$invalidate(0, activeSection);
	}

	$$self.$capture_state = () => ({
		Fullpage,
		FullpageSection,
		FullpageSlide,
		Container,
		Row,
		Col,
		sections,
		activeSection,
		slides,
		activeSlide
	});

	$$self.$inject_state = $$props => {
		if ("activeSection" in $$props) $$invalidate(0, activeSection = $$props.activeSection);
		if ("activeSlide" in $$props) $$invalidate(1, activeSlide = $$props.activeSlide);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		activeSection,
		activeSlide,
		sections,
		slides,
		fullpagesection0_activeSection_binding,
		fullpageslide0_activeSlide_binding,
		fullpageslide1_activeSlide_binding,
		fullpageslide2_activeSlide_binding,
		fullpagesection1_activeSection_binding,
		fullpagesection1_activeSlide_binding,
		fullpagesection2_activeSection_binding,
		fullpagesection3_activeSection_binding,
		fullpage_activeSection_binding
	];
}

class Routes extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Routes",
			options,
			id: create_fragment$6.name
		});
	}
}

export default Routes;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNjdjYjU2MDUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUtZnVsbHBhZ2Uvc3JjL0Z1bGxwYWdlLnN2ZWx0ZSIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvZWFzaW5nL2luZGV4Lm1qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvdHJhbnNpdGlvbi9pbmRleC5tanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlLWZ1bGxwYWdlL3NyYy9GdWxscGFnZVNlY3Rpb24uc3ZlbHRlIiwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N2ZWx0ZS1mdWxscGFnZS9zcmMvRnVsbHBhZ2VTbGlkZS5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY2xzeC9kaXN0L2Nsc3gubS5qcyIsIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGVzdHJhcC9zcmMvdXRpbHMuanMiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlc3RyYXAvc3JjL0NvbnRhaW5lci5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlc3RyYXAvc3JjL1Jvdy5zdmVsdGUiLCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlc3RyYXAvc3JjL0NvbC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2luZGV4LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICAgIC8vZGVmaW5pbmcgdmFyaWFibGUgdGhhdCB3aWxsIGhvbGQgY2xhc3MgdmFsdWUsIHRoYXQgd2lsbCBiZSBwYXNzZWQgaW50byB0aGlzIGNvbXBvbmVudCdzIHdyYXBwZXJcbiAgICBsZXQgZGVmYXVsdENsYXNzZXMgPSAnJztcblxuICAgIC8vaW1wb3J0aW5nIHNsaWRlIGFuaW1hdGlvbiBmcm9tIHN2ZWx0ZVxuICAgIC8vaW1wb3J0IHtzbGlkZX0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuXG4gICAgLy9leHBvcnRpbmcgY2xhc3NlcywgZm9yIHBhc3NpbmcgY2xhc3NlcyBpbnRvIHdyYXBwZXJcbiAgICBleHBvcnQge2RlZmF1bHRDbGFzc2VzIGFzIGNsYXNzfTtcbiAgICBleHBvcnQgbGV0IHN0eWxlID0gJyc7XG4gICAgLy9udW1iZXIgdGhhdCBob2xkIHdoaWNoIHNlY3Rpb24gaXMgYWN0aXZlXG4gICAgZXhwb3J0IGxldCBhY3RpdmVTZWN0aW9uID0gMDtcbiAgICAvL2FycmF5IHdpdGggbmFtZXMgb2Ygc2VjdGlvbiwgdGhlIG1vc3QgaW1wb3J0YW50IGFib3V0IHRoaXMgYXJyYXkgaXMgdGhhdCBpdCdzIGhvbGQgZnVsbHBhZ2UncyBsZW5ndGhcbiAgICBleHBvcnQgbGV0IHNlY3Rpb25zID0gW107XG4gICAgLy9leHBvcnRpbmcgZHVyYXRpb24gb2YgYW5pbWF0aW9uIGFuZCBzY3JvbGwgY29vbGRvd25cbiAgICBleHBvcnQgbGV0IHRyYW5zaXRpb25EdXJhdGlvbiA9IDUwMDtcbiAgICAvL2V4cG9ydGluZyBib29sZWFuIHRoYXQgZW5hYmxlcyBzY3JvbGxpbmcgdXNpbmcgYXJyb3dzXG4gICAgZXhwb3J0IGxldCBhcnJvd3MgPSBmYWxzZTtcbiAgICAvL2V4cG9ydGluZyBib29sZWFuIHRoYXQgZW5hYmxlcyBzY3JvbGxpbmcgdXNpbmcgZHJhZ1xuICAgIGV4cG9ydCBsZXQgZHJhZyA9IGZhbHNlO1xuXG4gICAgbGV0IGRyYWdTdGFydFBvc2l0aW9uO1xuICAgIGxldCB0b3VjaFN0YXJ0UG9zaXRpb247XG5cbiAgICAvL2V4dGVuZGluZyBleHBvcnRlZCBjbGFzc2VzIHdpdGggd3JhcHBlciBjbGFzc1xuICAgIGxldCBjbGFzc2VzID0gYCR7ZGVmYXVsdENsYXNzZXN9IHN2ZWx0ZS1mcC13cmFwcGVyYDtcbiAgICBsZXQgcmVjZW50U2Nyb2xsID0gMDtcbiAgICAvL3NldHRpbmcgc2VjdGlvbiB2aXNpYmxlXG4gICAgbGV0IGFjdGl2ZSA9IHRydWU7XG5cbiAgICAvL2Z1bmN0aW9uIHRoYXQgaGFuZGxlcyBzY3JvbGwgYW5kIHNldHMgc2Nyb2xsIGNvb2xkb3duIGJhc2VkIG9uIGFuaW1hdGlvbiBkdXJhdGlvblxuICAgIGNvbnN0IGhhbmRsZVNjcm9sbCA9IChldmVudCkgPT4ge1xuICAgICAgICAvL2dldHRpbmcgZGlyZWN0aW9uIG9mIHNjcm9sbCwgaWYgbmVnYXRpdmUsIHNjcm9sbCB1cCwgaWYgcG9zaXRpdmUsIHNjcm9sbCBkb3duXG4gICAgICAgIGxldCBkZWx0YVkgPSBldmVudC5kZWx0YVk7XG4gICAgICAgIGxldCB0aW1lciA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAvL2lmIGNvb2xkb3duIHRpbWUgaXMgdXAsIGZ1bGxwYWdlIGlzIHNjcm9sbGFibGUgYWdhaW5cbiAgICAgICAgaWYgKHRyYW5zaXRpb25EdXJhdGlvbiA8IHRpbWVyLXJlY2VudFNjcm9sbCkge1xuICAgICAgICAgICAgcmVjZW50U2Nyb2xsID0gdGltZXI7XG4gICAgICAgICAgICBpZiAoZGVsdGFZIDwgMCkge1xuICAgICAgICAgICAgICAgIHNjcm9sbFVwKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVsdGFZID4gMCkge1xuICAgICAgICAgICAgICAgIHNjcm9sbERvd24oKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvL2Z1bmN0aW9uIHRoYXQgdG9nZ2xlcyB2aXNpYmlsaXR5IG9mIGFjdGl2ZSBzZWN0aW9uXG4gICAgY29uc3QgdG9nZ2xlQWN0aXZlID0gKCkgPT4ge1xuICAgICAgICBhY3RpdmUgPSAhYWN0aXZlO1xuICAgIH07XG4gICAgLy9mdW5jdGlvbiB0aGF0IG1ha2VzIHNjcm9sbCB1cCBlZmZlY3RcbiAgICBjb25zdCBzY3JvbGxVcCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gVE9ETzogc29tZWhvdyBmaXggYW5pbWF0aW9uXG4gICAgICAgIGlmIChhY3RpdmVTZWN0aW9uID4gMCl7XG4gICAgICAgICAgICBhY3RpdmVTZWN0aW9uLS07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vZnVuY3Rpb24gdGhhdCBtYWtlcyBzY3JvbGwgZG93biBlZmZlY3RcbiAgICBjb25zdCBzY3JvbGxEb3duID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBUT0RPOiBzb21laG93IGZpeCBhbmltYXRpb25cbiAgICAgICAgaWYgKGFjdGl2ZVNlY3Rpb24gPCBzZWN0aW9ucy5sZW5ndGgtMSl7XG4gICAgICAgICAgICBhY3RpdmVTZWN0aW9uKys7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vZnVuY3Rpb24gdGhhdCBoYW5kbGVzIGFycm93IGV2ZW50XG4gICAgY29uc3QgaGFuZGxlS2V5ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChhcnJvd3MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsRG93bigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsVXAoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vZnVuY3Rpb24gdGhhdCBoYW5kbGVzIGRyYWcgc3RhcnQgZXZlbnRcbiAgICBjb25zdCBoYW5kbGVEcmFnU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGRyYWcpIHtcbiAgICAgICAgICAgIGRyYWdTdGFydFBvc2l0aW9uID0gZXZlbnQuc2NyZWVuWTtcbiAgICAgICAgfVxuICAgICAgICAvL2V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICAvL2Z1bmN0aW9uIHRoYXQgaGFuZGxlcyBkcmFnIGVuZCBldmVudFxuICAgIGNvbnN0IGhhbmRsZURyYWdFbmQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGRyYWcpIHtcbiAgICAgICAgICAgIGNvbnN0IGRyYWdFbmRQb3NpdGlvbiA9IGV2ZW50LnNjcmVlblk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGBTdGFydDoke2RyYWdTdGFydFBvc2l0aW9ufSwgRW5kOiR7ZHJhZ0VuZFBvc2l0aW9ufSwgdmVydGljYWwgZGlmZmVyZW5jZToke2RyYWdTdGFydFBvc2l0aW9uLWRyYWdFbmRQb3NpdGlvbn1gKTtcbiAgICAgICAgICAgIGlmIChkcmFnU3RhcnRQb3NpdGlvbiAtIGRyYWdFbmRQb3NpdGlvbiA+IDEwMCkge1xuICAgICAgICAgICAgICAgIHNjcm9sbERvd24oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHJhZ1N0YXJ0UG9zaXRpb24gLSBkcmFnRW5kUG9zaXRpb24gPCAtMTAwKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVXAoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9O1xuICAgIC8vZnVuY3Rpb24gdGhhdCBoYW5kbGVzIHRvdWNoIGV2ZW50XG4gICAgY29uc3QgaGFuZGxlVG91Y2hTdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICAvL2V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRvdWNoU3RhcnRQb3NpdGlvbiA9IGV2ZW50LnRvdWNoZXNbMF0uc2NyZWVuWTtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVRvdWNoRW5kID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgbGV0IHRpbWVyID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIGNvbnN0IHRvdWNoRW5kUG9zaXRpb24gPSBldmVudC50b3VjaGVzWzBdLnNjcmVlblk7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uRHVyYXRpb24gPCB0aW1lci1yZWNlbnRTY3JvbGwpIHtcbiAgICAgICAgICAgIGlmICh0b3VjaFN0YXJ0UG9zaXRpb24gLSB0b3VjaEVuZFBvc2l0aW9uID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsRG93bigpO1xuICAgICAgICAgICAgICAgIHJlY2VudFNjcm9sbCA9IHRpbWVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b3VjaFN0YXJ0UG9zaXRpb24gLSB0b3VjaEVuZFBvc2l0aW9uIDwgLTEwMCkge1xuICAgICAgICAgICAgICAgIHNjcm9sbFVwKCk7XG4gICAgICAgICAgICAgICAgcmVjZW50U2Nyb2xsID0gdGltZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFRPRE86IHNsaWRlXG48L3NjcmlwdD5cblxuPHN2ZWx0ZTp3aW5kb3cgb246a2V5ZG93bj17IChldmVudCk9PmhhbmRsZUtleShldmVudCkgfS8+XG5cblxuPGRpdiBjbGFzcz17Y2xhc3Nlc30gc3R5bGU9e3N0eWxlfSBvbjp3aGVlbD17IChldmVudCk9PmhhbmRsZVNjcm9sbChldmVudCkgfSBvbjp0b3VjaHN0YXJ0PXsgKGV2ZW50KT0+aGFuZGxlVG91Y2hTdGFydChldmVudCkgfSBvbjp0b3VjaG1vdmU9eyAoZXZlbnQpPT5oYW5kbGVUb3VjaEVuZChldmVudCkgfVxuICAgICAgICBvbjpkcmFnPXsgKCk9PntyZXR1cm4gZmFsc2V9IH0gb246bW91c2Vkb3duPXsgKGV2ZW50KT0+aGFuZGxlRHJhZ1N0YXJ0KGV2ZW50KSB9IG9uOm1vdXNldXA9eyAoZXZlbnQpPT5oYW5kbGVEcmFnRW5kKGV2ZW50KSB9PlxuICAgIDxkaXYgY2xhc3M9XCJzdmVsdGUtZnAtY29udGFpbmVyXCI+XG4gICAgICAgIDxzbG90IC8+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzdmVsdGUtZnAtaW5kaWNhdG9yXCI+XG4gICAgICAgICAgICA8dWwgY2xhc3M9XCJzdmVsdGUtZnAtaW5kaWNhdG9yLWxpc3RcIj5cbiAgICAgICAgICAgICAgICB7I2VhY2ggc2VjdGlvbnMgYXMgcGFnZSxpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVwic3ZlbHRlLWZwLWluZGljYXRvci1saXN0LWl0ZW1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJzdmVsdGUtZnAtaW5kaWNhdG9yLWxpc3QtaXRlbS1idG4ge2FjdGl2ZVNlY3Rpb24gPT09IGluZGV4ID8gJ3N2ZWx0ZS1mcC1hY3RpdmUnOicnfVwiIG9uOmNsaWNrPXsgKCk9PmFjdGl2ZVNlY3Rpb249aW5kZXggfT48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuXG48c3R5bGU+XG4gICAgLnN2ZWx0ZS1mcC13cmFwcGVyIHtcbiAgICAgICAgaGVpZ2h0OiAxMDB2aDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgIH1cbiAgICAuc3ZlbHRlLWZwLWNvbnRhaW5lciB7XG4gICAgICAgIGhlaWdodDogaW5oZXJpdDtcbiAgICAgICAgd2lkdGg6IGluaGVyaXQ7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG4gICAgLnN2ZWx0ZS1mcC1pbmRpY2F0b3Ige1xuICAgICAgICBoZWlnaHQ6IGluaGVyaXQ7XG4gICAgICAgIHdpZHRoOiA1cmVtO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgfVxuICAgIC5zdmVsdGUtZnAtaW5kaWNhdG9yLWxpc3Qge1xuICAgICAgICBtYXJnaW46IDFyZW07XG4gICAgICAgIHBhZGRpbmc6IDFyZW07XG4gICAgICAgIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcbiAgICB9XG4gICAgLnN2ZWx0ZS1mcC1pbmRpY2F0b3ItbGlzdC1pdGVtIHtcbiAgICAgICAgbWFyZ2luOiAxcmVtO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgIH1cbiAgICAuc3ZlbHRlLWZwLWluZGljYXRvci1saXN0LWl0ZW0tYnRuIHtcbiAgICAgICAgd2lkdGg6IDFyZW07XG4gICAgICAgIGhlaWdodDogMXJlbTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMC41cmVtO1xuICAgICAgICBib3JkZXI6IHNvbGlkIDFweCAjNzY3Njc2O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICB9XG4gICAgLnN2ZWx0ZS1mcC1hY3RpdmUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNzY3Njc2O1xuICAgIH1cbiAgICBAbWVkaWEgb25seSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDYwMHB4KXtcbiAgICAgICAgLnN2ZWx0ZS1mcC1pbmRpY2F0b3Ige1xuICAgICAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgICAgfVxuICAgIH1cbjwvc3R5bGU+IiwiZXhwb3J0IHsgaWRlbnRpdHkgYXMgbGluZWFyIH0gZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG4vKlxuQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXR0ZGVzbFxuRGlzdHJpYnV0ZWQgdW5kZXIgTUlUIExpY2Vuc2UgaHR0cHM6Ly9naXRodWIuY29tL21hdHRkZXNsL2Vhc2VzL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcbiovXG5mdW5jdGlvbiBiYWNrSW5PdXQodCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4ICogMS41MjU7XG4gICAgaWYgKCh0ICo9IDIpIDwgMSlcbiAgICAgICAgcmV0dXJuIDAuNSAqICh0ICogdCAqICgocyArIDEpICogdCAtIHMpKTtcbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgocyArIDEpICogdCArIHMpICsgMik7XG59XG5mdW5jdGlvbiBiYWNrSW4odCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xufVxuZnVuY3Rpb24gYmFja091dCh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG59XG5mdW5jdGlvbiBib3VuY2VPdXQodCkge1xuICAgIGNvbnN0IGEgPSA0LjAgLyAxMS4wO1xuICAgIGNvbnN0IGIgPSA4LjAgLyAxMS4wO1xuICAgIGNvbnN0IGMgPSA5LjAgLyAxMC4wO1xuICAgIGNvbnN0IGNhID0gNDM1Ni4wIC8gMzYxLjA7XG4gICAgY29uc3QgY2IgPSAzNTQ0Mi4wIC8gMTgwNS4wO1xuICAgIGNvbnN0IGNjID0gMTYwNjEuMCAvIDE4MDUuMDtcbiAgICBjb25zdCB0MiA9IHQgKiB0O1xuICAgIHJldHVybiB0IDwgYVxuICAgICAgICA/IDcuNTYyNSAqIHQyXG4gICAgICAgIDogdCA8IGJcbiAgICAgICAgICAgID8gOS4wNzUgKiB0MiAtIDkuOSAqIHQgKyAzLjRcbiAgICAgICAgICAgIDogdCA8IGNcbiAgICAgICAgICAgICAgICA/IGNhICogdDIgLSBjYiAqIHQgKyBjY1xuICAgICAgICAgICAgICAgIDogMTAuOCAqIHQgKiB0IC0gMjAuNTIgKiB0ICsgMTAuNzI7XG59XG5mdW5jdGlvbiBib3VuY2VJbk91dCh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKiAoMS4wIC0gYm91bmNlT3V0KDEuMCAtIHQgKiAyLjApKVxuICAgICAgICA6IDAuNSAqIGJvdW5jZU91dCh0ICogMi4wIC0gMS4wKSArIDAuNTtcbn1cbmZ1bmN0aW9uIGJvdW5jZUluKHQpIHtcbiAgICByZXR1cm4gMS4wIC0gYm91bmNlT3V0KDEuMCAtIHQpO1xufVxuZnVuY3Rpb24gY2lyY0luT3V0KHQpIHtcbiAgICBpZiAoKHQgKj0gMikgPCAxKVxuICAgICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpO1xuICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSk7XG59XG5mdW5jdGlvbiBjaXJjSW4odCkge1xuICAgIHJldHVybiAxLjAgLSBNYXRoLnNxcnQoMS4wIC0gdCAqIHQpO1xufVxuZnVuY3Rpb24gY2lyY091dCh0KSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgxIC0gLS10ICogdCk7XG59XG5mdW5jdGlvbiBjdWJpY0luT3V0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDQuMCAqIHQgKiB0ICogdCA6IDAuNSAqIE1hdGgucG93KDIuMCAqIHQgLSAyLjAsIDMuMCkgKyAxLjA7XG59XG5mdW5jdGlvbiBjdWJpY0luKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xufVxuZnVuY3Rpb24gY3ViaWNPdXQodCkge1xuICAgIGNvbnN0IGYgPSB0IC0gMS4wO1xuICAgIHJldHVybiBmICogZiAqIGYgKyAxLjA7XG59XG5mdW5jdGlvbiBlbGFzdGljSW5PdXQodCkge1xuICAgIHJldHVybiB0IDwgMC41XG4gICAgICAgID8gMC41ICpcbiAgICAgICAgICAgIE1hdGguc2luKCgoKzEzLjAgKiBNYXRoLlBJKSAvIDIpICogMi4wICogdCkgKlxuICAgICAgICAgICAgTWF0aC5wb3coMi4wLCAxMC4wICogKDIuMCAqIHQgLSAxLjApKVxuICAgICAgICA6IDAuNSAqXG4gICAgICAgICAgICBNYXRoLnNpbigoKC0xMy4wICogTWF0aC5QSSkgLyAyKSAqICgyLjAgKiB0IC0gMS4wICsgMS4wKSkgKlxuICAgICAgICAgICAgTWF0aC5wb3coMi4wLCAtMTAuMCAqICgyLjAgKiB0IC0gMS4wKSkgK1xuICAgICAgICAgICAgMS4wO1xufVxuZnVuY3Rpb24gZWxhc3RpY0luKHQpIHtcbiAgICByZXR1cm4gTWF0aC5zaW4oKDEzLjAgKiB0ICogTWF0aC5QSSkgLyAyKSAqIE1hdGgucG93KDIuMCwgMTAuMCAqICh0IC0gMS4wKSk7XG59XG5mdW5jdGlvbiBlbGFzdGljT3V0KHQpIHtcbiAgICByZXR1cm4gKE1hdGguc2luKCgtMTMuMCAqICh0ICsgMS4wKSAqIE1hdGguUEkpIC8gMikgKiBNYXRoLnBvdygyLjAsIC0xMC4wICogdCkgKyAxLjApO1xufVxuZnVuY3Rpb24gZXhwb0luT3V0KHQpIHtcbiAgICByZXR1cm4gdCA9PT0gMC4wIHx8IHQgPT09IDEuMFxuICAgICAgICA/IHRcbiAgICAgICAgOiB0IDwgMC41XG4gICAgICAgICAgICA/ICswLjUgKiBNYXRoLnBvdygyLjAsIDIwLjAgKiB0IC0gMTAuMClcbiAgICAgICAgICAgIDogLTAuNSAqIE1hdGgucG93KDIuMCwgMTAuMCAtIHQgKiAyMC4wKSArIDEuMDtcbn1cbmZ1bmN0aW9uIGV4cG9Jbih0KSB7XG4gICAgcmV0dXJuIHQgPT09IDAuMCA/IHQgOiBNYXRoLnBvdygyLjAsIDEwLjAgKiAodCAtIDEuMCkpO1xufVxuZnVuY3Rpb24gZXhwb091dCh0KSB7XG4gICAgcmV0dXJuIHQgPT09IDEuMCA/IHQgOiAxLjAgLSBNYXRoLnBvdygyLjAsIC0xMC4wICogdCk7XG59XG5mdW5jdGlvbiBxdWFkSW5PdXQodCkge1xuICAgIHQgLz0gMC41O1xuICAgIGlmICh0IDwgMSlcbiAgICAgICAgcmV0dXJuIDAuNSAqIHQgKiB0O1xuICAgIHQtLTtcbiAgICByZXR1cm4gLTAuNSAqICh0ICogKHQgLSAyKSAtIDEpO1xufVxuZnVuY3Rpb24gcXVhZEluKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG59XG5mdW5jdGlvbiBxdWFkT3V0KHQpIHtcbiAgICByZXR1cm4gLXQgKiAodCAtIDIuMCk7XG59XG5mdW5jdGlvbiBxdWFydEluT3V0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNVxuICAgICAgICA/ICs4LjAgKiBNYXRoLnBvdyh0LCA0LjApXG4gICAgICAgIDogLTguMCAqIE1hdGgucG93KHQgLSAxLjAsIDQuMCkgKyAxLjA7XG59XG5mdW5jdGlvbiBxdWFydEluKHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3codCwgNC4wKTtcbn1cbmZ1bmN0aW9uIHF1YXJ0T3V0KHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3codCAtIDEuMCwgMy4wKSAqICgxLjAgLSB0KSArIDEuMDtcbn1cbmZ1bmN0aW9uIHF1aW50SW5PdXQodCkge1xuICAgIGlmICgodCAqPSAyKSA8IDEpXG4gICAgICAgIHJldHVybiAwLjUgKiB0ICogdCAqIHQgKiB0ICogdDtcbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0ICogdCArIDIpO1xufVxuZnVuY3Rpb24gcXVpbnRJbih0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHQgKiB0O1xufVxuZnVuY3Rpb24gcXVpbnRPdXQodCkge1xuICAgIHJldHVybiAtLXQgKiB0ICogdCAqIHQgKiB0ICsgMTtcbn1cbmZ1bmN0aW9uIHNpbmVJbk91dCh0KSB7XG4gICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5jb3MoTWF0aC5QSSAqIHQpIC0gMSk7XG59XG5mdW5jdGlvbiBzaW5lSW4odCkge1xuICAgIGNvbnN0IHYgPSBNYXRoLmNvcyh0ICogTWF0aC5QSSAqIDAuNSk7XG4gICAgaWYgKE1hdGguYWJzKHYpIDwgMWUtMTQpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIDEgLSB2O1xufVxuZnVuY3Rpb24gc2luZU91dCh0KSB7XG4gICAgcmV0dXJuIE1hdGguc2luKCh0ICogTWF0aC5QSSkgLyAyKTtcbn1cblxuZXhwb3J0IHsgYmFja0luLCBiYWNrSW5PdXQsIGJhY2tPdXQsIGJvdW5jZUluLCBib3VuY2VJbk91dCwgYm91bmNlT3V0LCBjaXJjSW4sIGNpcmNJbk91dCwgY2lyY091dCwgY3ViaWNJbiwgY3ViaWNJbk91dCwgY3ViaWNPdXQsIGVsYXN0aWNJbiwgZWxhc3RpY0luT3V0LCBlbGFzdGljT3V0LCBleHBvSW4sIGV4cG9Jbk91dCwgZXhwb091dCwgcXVhZEluLCBxdWFkSW5PdXQsIHF1YWRPdXQsIHF1YXJ0SW4sIHF1YXJ0SW5PdXQsIHF1YXJ0T3V0LCBxdWludEluLCBxdWludEluT3V0LCBxdWludE91dCwgc2luZUluLCBzaW5lSW5PdXQsIHNpbmVPdXQgfTtcbiIsImltcG9ydCB7IGN1YmljSW5PdXQsIGxpbmVhciwgY3ViaWNPdXQgfSBmcm9tICcuLi9lYXNpbmcnO1xuaW1wb3J0IHsgaXNfZnVuY3Rpb24sIGFzc2lnbiB9IGZyb20gJy4uL2ludGVybmFsJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxuXG5mdW5jdGlvbiBibHVyKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNJbk91dCwgYW1vdW50ID0gNSwgb3BhY2l0eSA9IDAgfSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IGYgPSBzdHlsZS5maWx0ZXIgPT09ICdub25lJyA/ICcnIDogc3R5bGUuZmlsdGVyO1xuICAgIGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IChfdCwgdSkgPT4gYG9wYWNpdHk6ICR7dGFyZ2V0X29wYWNpdHkgLSAob2QgKiB1KX07IGZpbHRlcjogJHtmfSBibHVyKCR7dSAqIGFtb3VudH1weCk7YFxuICAgIH07XG59XG5mdW5jdGlvbiBmYWRlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gbGluZWFyIH0pIHtcbiAgICBjb25zdCBvID0gK2dldENvbXB1dGVkU3R5bGUobm9kZSkub3BhY2l0eTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiB0ID0+IGBvcGFjaXR5OiAke3QgKiBvfWBcbiAgICB9O1xufVxuZnVuY3Rpb24gZmx5KG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNPdXQsIHggPSAwLCB5ID0gMCwgb3BhY2l0eSA9IDAgfSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgY29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKHQsIHUpID0+IGBcblx0XHRcdHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgkeygxIC0gdCkgKiB4fXB4LCAkeygxIC0gdCkgKiB5fXB4KTtcblx0XHRcdG9wYWNpdHk6ICR7dGFyZ2V0X29wYWNpdHkgLSAob2QgKiB1KX1gXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNsaWRlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNPdXQgfSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCBvcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgaGVpZ2h0ID0gcGFyc2VGbG9hdChzdHlsZS5oZWlnaHQpO1xuICAgIGNvbnN0IHBhZGRpbmdfdG9wID0gcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nVG9wKTtcbiAgICBjb25zdCBwYWRkaW5nX2JvdHRvbSA9IHBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ0JvdHRvbSk7XG4gICAgY29uc3QgbWFyZ2luX3RvcCA9IHBhcnNlRmxvYXQoc3R5bGUubWFyZ2luVG9wKTtcbiAgICBjb25zdCBtYXJnaW5fYm90dG9tID0gcGFyc2VGbG9hdChzdHlsZS5tYXJnaW5Cb3R0b20pO1xuICAgIGNvbnN0IGJvcmRlcl90b3Bfd2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlLmJvcmRlclRvcFdpZHRoKTtcbiAgICBjb25zdCBib3JkZXJfYm90dG9tX3dpZHRoID0gcGFyc2VGbG9hdChzdHlsZS5ib3JkZXJCb3R0b21XaWR0aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogdCA9PiBgb3ZlcmZsb3c6IGhpZGRlbjtgICtcbiAgICAgICAgICAgIGBvcGFjaXR5OiAke01hdGgubWluKHQgKiAyMCwgMSkgKiBvcGFjaXR5fTtgICtcbiAgICAgICAgICAgIGBoZWlnaHQ6ICR7dCAqIGhlaWdodH1weDtgICtcbiAgICAgICAgICAgIGBwYWRkaW5nLXRvcDogJHt0ICogcGFkZGluZ190b3B9cHg7YCArXG4gICAgICAgICAgICBgcGFkZGluZy1ib3R0b206ICR7dCAqIHBhZGRpbmdfYm90dG9tfXB4O2AgK1xuICAgICAgICAgICAgYG1hcmdpbi10b3A6ICR7dCAqIG1hcmdpbl90b3B9cHg7YCArXG4gICAgICAgICAgICBgbWFyZ2luLWJvdHRvbTogJHt0ICogbWFyZ2luX2JvdHRvbX1weDtgICtcbiAgICAgICAgICAgIGBib3JkZXItdG9wLXdpZHRoOiAke3QgKiBib3JkZXJfdG9wX3dpZHRofXB4O2AgK1xuICAgICAgICAgICAgYGJvcmRlci1ib3R0b20td2lkdGg6ICR7dCAqIGJvcmRlcl9ib3R0b21fd2lkdGh9cHg7YFxuICAgIH07XG59XG5mdW5jdGlvbiBzY2FsZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0LCBzdGFydCA9IDAsIG9wYWNpdHkgPSAwIH0pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgIGNvbnN0IHNkID0gMSAtIHN0YXJ0O1xuICAgIGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IChfdCwgdSkgPT4gYFxuXHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gc2NhbGUoJHsxIC0gKHNkICogdSl9KTtcblx0XHRcdG9wYWNpdHk6ICR7dGFyZ2V0X29wYWNpdHkgLSAob2QgKiB1KX1cblx0XHRgXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRyYXcobm9kZSwgeyBkZWxheSA9IDAsIHNwZWVkLCBkdXJhdGlvbiwgZWFzaW5nID0gY3ViaWNJbk91dCB9KSB7XG4gICAgY29uc3QgbGVuID0gbm9kZS5nZXRUb3RhbExlbmd0aCgpO1xuICAgIGlmIChkdXJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzcGVlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IDgwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gbGVuIC8gc3BlZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGR1cmF0aW9uID0gZHVyYXRpb24obGVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKHQsIHUpID0+IGBzdHJva2UtZGFzaGFycmF5OiAke3QgKiBsZW59ICR7dSAqIGxlbn1gXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyb3NzZmFkZShfYSkge1xuICAgIHZhciB7IGZhbGxiYWNrIH0gPSBfYSwgZGVmYXVsdHMgPSBfX3Jlc3QoX2EsIFtcImZhbGxiYWNrXCJdKTtcbiAgICBjb25zdCB0b19yZWNlaXZlID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHRvX3NlbmQgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gY3Jvc3NmYWRlKGZyb20sIG5vZGUsIHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSBkID0+IE1hdGguc3FydChkKSAqIDMwLCBlYXNpbmcgPSBjdWJpY091dCB9ID0gYXNzaWduKGFzc2lnbih7fSwgZGVmYXVsdHMpLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCB0byA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IGR4ID0gZnJvbS5sZWZ0IC0gdG8ubGVmdDtcbiAgICAgICAgY29uc3QgZHkgPSBmcm9tLnRvcCAtIHRvLnRvcDtcbiAgICAgICAgY29uc3QgZHcgPSBmcm9tLndpZHRoIC8gdG8ud2lkdGg7XG4gICAgICAgIGNvbnN0IGRoID0gZnJvbS5oZWlnaHQgLyB0by5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgICAgZHVyYXRpb246IGlzX2Z1bmN0aW9uKGR1cmF0aW9uKSA/IGR1cmF0aW9uKGQpIDogZHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmcsXG4gICAgICAgICAgICBjc3M6ICh0LCB1KSA9PiBgXG5cdFx0XHRcdG9wYWNpdHk6ICR7dCAqIG9wYWNpdHl9O1xuXHRcdFx0XHR0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdDtcblx0XHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7dSAqIGR4fXB4LCR7dSAqIGR5fXB4KSBzY2FsZSgke3QgKyAoMSAtIHQpICogZHd9LCAke3QgKyAoMSAtIHQpICogZGh9KTtcblx0XHRcdGBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbihpdGVtcywgY291bnRlcnBhcnRzLCBpbnRybykge1xuICAgICAgICByZXR1cm4gKG5vZGUsIHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgaXRlbXMuc2V0KHBhcmFtcy5rZXksIHtcbiAgICAgICAgICAgICAgICByZWN0OiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ZXJwYXJ0cy5oYXMocGFyYW1zLmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByZWN0IH0gPSBjb3VudGVycGFydHMuZ2V0KHBhcmFtcy5rZXkpO1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVycGFydHMuZGVsZXRlKHBhcmFtcy5rZXkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3Jvc3NmYWRlKHJlY3QsIG5vZGUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGlzIGRpc2FwcGVhcmluZyBhbHRvZ2V0aGVyXG4gICAgICAgICAgICAgICAgLy8gKGkuZS4gd2Fzbid0IGNsYWltZWQgYnkgdGhlIG90aGVyIGxpc3QpXG4gICAgICAgICAgICAgICAgLy8gdGhlbiB3ZSBuZWVkIHRvIHN1cHBseSBhbiBvdXRyb1xuICAgICAgICAgICAgICAgIGl0ZW1zLmRlbGV0ZShwYXJhbXMua2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsbGJhY2sgJiYgZmFsbGJhY2sobm9kZSwgcGFyYW1zLCBpbnRybyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICB0cmFuc2l0aW9uKHRvX3NlbmQsIHRvX3JlY2VpdmUsIGZhbHNlKSxcbiAgICAgICAgdHJhbnNpdGlvbih0b19yZWNlaXZlLCB0b19zZW5kLCB0cnVlKVxuICAgIF07XG59XG5cbmV4cG9ydCB7IGJsdXIsIGNyb3NzZmFkZSwgZHJhdywgZmFkZSwgZmx5LCBzY2FsZSwgc2xpZGUgfTtcbiIsIjxzY3JpcHQ+XG4gICAgaW1wb3J0IHtzbGlkZX0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nO1xuXG4gICAgLy88RnVsbHBhZ2VTZWN0aW9uU3RhdGljIGJpbmQ6YWN0aXZlU2VjdGlvbiBzZWN0aW9uSWQ9XCJpZFwiPjwvRnVsbHBhZ2VTZWN0aW9uU3RhdGljPlxuXG4gICAgbGV0IGRlZmF1bHRDbGFzc2VzID0gJyc7XG5cbiAgICBleHBvcnQgeyBkZWZhdWx0Q2xhc3NlcyBhcyBjbGFzcyB9O1xuICAgIGV4cG9ydCBsZXQgc3R5bGUgPSAnJztcbiAgICBleHBvcnQgbGV0IHNlY3Rpb25JZDtcbiAgICBleHBvcnQgbGV0IGFjdGl2ZVNlY3Rpb247XG4gICAgZXhwb3J0IGxldCBzbGlkZXMgPSBbXTtcbiAgICBleHBvcnQgbGV0IGFjdGl2ZVNsaWRlID0gZmFsc2U7XG4gICAgZXhwb3J0IGxldCBjZW50ZXIgPSBmYWxzZTtcbiAgICBleHBvcnQgbGV0IGFycm93cyA9IGZhbHNlO1xuICAgIGV4cG9ydCBsZXQgc2VsZWN0ID0gZmFsc2U7XG4gICAgZXhwb3J0IGxldCB0cmFuc2l0aW9uRHVyYXRpb24gPSA1MDA7XG4gICAgZXhwb3J0IGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgICBkdXJhdGlvbjogdHJhbnNpdGlvbkR1cmF0aW9uXG4gICAgfTtcbiAgICBzZWN0aW9uSWQgPSBwYXJzZUludChzZWN0aW9uSWQpO1xuXG4gICAgbGV0IGRyYWdTdGFydFBvc2l0aW9uO1xuICAgIGxldCB0b3VjaFN0YXJ0UG9zaXRpb247XG4gICAgbGV0IHJlY2VudFNsaWRlID0gMDtcblxuICAgIGxldCBjbGFzc2VzID0gYCR7ZGVmYXVsdENsYXNzZXN9IHN2ZWx0ZS1mcC1zZWN0aW9uIHN2ZWx0ZS1mcC1mbGV4Ym94LWNlbnRlcmA7XG5cbiAgICBpZiAoIXNlbGVjdCkge1xuICAgICAgICBjbGFzc2VzID0gYCR7Y2xhc3Nlc30gc3ZlbHRlLWZwLXVuc2VsZWN0YWJsZWBcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVTZWxlY3QgPSAoKSA9PiB7XG4gICAgICAgIGlmICghc2VsZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc2xpZGVSaWdodCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZVNsaWRlIDwgc2xpZGVzLmxlbmd0aC0xKXtcbiAgICAgICAgICAgIGFjdGl2ZVNsaWRlKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVTbGlkZSA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc2xpZGVMZWZ0ID0gKCkgPT4ge1xuICAgICAgICBpZiAoYWN0aXZlU2xpZGUgPiAwKSB7XG4gICAgICAgICAgICBhY3RpdmVTbGlkZS0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlU2xpZGUgPSBzbGlkZXMubGVuZ3RoLTE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9mdW5jdGlvbiB0aGF0IGhhbmRsZXMgYXJyb3cgZXZlbnRcbiAgICBjb25zdCBoYW5kbGVLZXkgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGFycm93cykge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICAgICAgICAgICAgICBzbGlkZUxlZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlUmlnaHQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy9mdW5jdGlvbiB0aGF0IGhhbmRsZXMgZHJhZyBzdGFydCBldmVudFxuICAgIGNvbnN0IGhhbmRsZURyYWdTdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICBkcmFnU3RhcnRQb3NpdGlvbiA9IGV2ZW50LnNjcmVlblg7XG4gICAgfTtcbiAgICAvL2Z1bmN0aW9uIHRoYXQgaGFuZGxlcyBkcmFnIGVuZCBldmVudFxuICAgIGNvbnN0IGhhbmRsZURyYWdFbmQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZHJhZ0VuZFBvc2l0aW9uID0gZXZlbnQuc2NyZWVuWDtcbiAgICAgICAgaWYgKGRyYWdTdGFydFBvc2l0aW9uIC0gZHJhZ0VuZFBvc2l0aW9uID4gMTAwKSB7XG4gICAgICAgICAgICBzbGlkZVJpZ2h0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZHJhZ1N0YXJ0UG9zaXRpb24gLSBkcmFnRW5kUG9zaXRpb24gPCAtMTAwKSB7XG4gICAgICAgICAgICBzbGlkZUxlZnQoKVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvL2Z1bmN0aW9uIHRoYXQgaGFuZGxlcyB0b3VjaCBldmVudFxuICAgIGNvbnN0IGhhbmRsZVRvdWNoU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgLy9ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0b3VjaFN0YXJ0UG9zaXRpb24gPSBldmVudC50b3VjaGVzWzBdLnNjcmVlblg7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVUb3VjaEVuZCA9IChldmVudCkgPT4ge1xuICAgICAgICAvL2V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGxldCB0aW1lciA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBjb25zdCB0b3VjaEVuZFBvc2l0aW9uID0gZXZlbnQudG91Y2hlc1swXS5zY3JlZW5YO1xuICAgICAgICBpZiAodHJhbnNpdGlvbkR1cmF0aW9uIDwgdGltZXItcmVjZW50U2xpZGUpIHtcbiAgICAgICAgICAgIGlmICh0b3VjaFN0YXJ0UG9zaXRpb24gLSB0b3VjaEVuZFBvc2l0aW9uID4gMTAwKSB7XG4gICAgICAgICAgICAgICAgc2xpZGVSaWdodCgpO1xuICAgICAgICAgICAgICAgIHJlY2VudFNsaWRlID0gdGltZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvdWNoU3RhcnRQb3NpdGlvbiAtIHRvdWNoRW5kUG9zaXRpb24gPCAtMTAwKSB7XG4gICAgICAgICAgICAgICAgc2xpZGVMZWZ0KCk7XG4gICAgICAgICAgICAgICAgcmVjZW50U2xpZGUgPSB0aW1lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbjwvc2NyaXB0PlxuXG48c3ZlbHRlOndpbmRvdyBvbjprZXlkb3duPXsgKGV2ZW50KT0+aGFuZGxlS2V5KGV2ZW50KSB9Lz5cblxueyNpZiBzZWN0aW9uSWQgPT09IGFjdGl2ZVNlY3Rpb259XG4gICAgPHNlY3Rpb24gdHJhbnNpdGlvbjpzbGlkZT17dHJhbnNpdGlvbn0gY2xhc3M9e2NsYXNzZXN9IHN0eWxlPXtzdHlsZX0gb246c2VsZWN0c3RhcnQ9e2hhbmRsZVNlbGVjdH1cbiAgICAgICAgICAgICBvbjptb3VzZWRvd249eyAoZXZlbnQpPT5oYW5kbGVEcmFnU3RhcnQoZXZlbnQpIH0gb246bW91c2V1cD17IChldmVudCk9PmhhbmRsZURyYWdFbmQoZXZlbnQpIH1cbiAgICAgICAgICAgIG9uOnRvdWNoc3RhcnQ9eyAoZXZlbnQpPT5oYW5kbGVUb3VjaFN0YXJ0KGV2ZW50KSB9IG9uOnRvdWNobW92ZT17IChldmVudCk9PmhhbmRsZVRvdWNoRW5kKGV2ZW50KSB9PlxuICAgICAgICA8ZGl2IGNsYXNzPVwic3ZlbHRlLWZwLWNvbnRhaW5lciBzdmVsdGUtZnAtZmxleGJveC1leHBhbmRcIiBjbGFzczpzdmVsdGUtZnAtZmxleGJveC1jZW50ZXI9e2NlbnRlcn0+XG4gICAgICAgICAgICA8c2xvdD5cbiAgICAgICAgICAgIDwvc2xvdD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIHsjaWYgc2xpZGVzWzBdfVxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN2ZWx0ZS1mcC1pbmRpY2F0b3ItaG9yaXpvbnRhbFwiPlxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cInN2ZWx0ZS1mcC1pbmRpY2F0b3ItbGlzdC1ob3Jpem9udGFsXCI+XG4gICAgICAgICAgICAgICAgICAgIHsjZWFjaCBzbGlkZXMgYXMgcGFnZSxpbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cInN2ZWx0ZS1mcC1pbmRpY2F0b3ItbGlzdC1pdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInN2ZWx0ZS1mcC1pbmRpY2F0b3ItbGlzdC1pdGVtLWJ0biB7YWN0aXZlU2xpZGUgPT09IGluZGV4ID8gJ3N2ZWx0ZS1mcC1hY3RpdmUnOicnfVwiIG9uOmNsaWNrPXsgKCk9PmFjdGl2ZVNsaWRlPWluZGV4IH0+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICAgICB7L2VhY2h9XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICB7L2lmfVxuICAgIDwvc2VjdGlvbj5cbnsvaWZ9XG5cbjxzdHlsZT5cbiAgICBzZWN0aW9uIHtcbiAgICAgICAgaGVpZ2h0OiBpbmhlcml0O1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgfVxuICAgIC5zdmVsdGUtZnAtZmxleGJveC1leHBhbmQge1xuICAgICAgICBmbGV4OiAxO1xuICAgIH1cbiAgICAuc3ZlbHRlLWZwLWNvbnRhaW5lciB7XG4gICAgICAgIGhlaWdodDogaW5oZXJpdDtcbiAgICAgICAgd2lkdGg6IGluaGVyaXQ7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB9XG4gICAgLnN2ZWx0ZS1mcC1mbGV4Ym94LWNlbnRlciB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIH1cbiAgICAuc3ZlbHRlLWZwLXVuc2VsZWN0YWJsZSB7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgIH1cbiAgICAuc3ZlbHRlLWZwLWluZGljYXRvci1ob3Jpem9udGFsIHtcbiAgICAgICAgd2lkdGg6IGluaGVyaXQ7XG4gICAgICAgIGhlaWdodDogNXJlbTtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB9XG4gICAgLnN2ZWx0ZS1mcC1pbmRpY2F0b3ItbGlzdC1ob3Jpem9udGFsIHtcbiAgICAgICAgbWFyZ2luOiAxcmVtO1xuICAgICAgICBwYWRkaW5nOiAxcmVtO1xuICAgICAgICBsaXN0LXN0eWxlLXR5cGU6IG5vbmU7XG4gICAgfVxuICAgIC5zdmVsdGUtZnAtaW5kaWNhdG9yLWxpc3QtaXRlbSB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgbWFyZ2luOiAxcmVtO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgIH1cbiAgICAuc3ZlbHRlLWZwLWluZGljYXRvci1saXN0LWl0ZW0tYnRuIHtcbiAgICAgICAgd2lkdGg6IDFyZW07XG4gICAgICAgIGhlaWdodDogMXJlbTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMC41cmVtO1xuICAgICAgICBib3JkZXI6IHNvbGlkIDFweCAjNzY3Njc2O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICB9XG4gICAgLnN2ZWx0ZS1mcC1hY3RpdmUge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjNzY3Njc2O1xuICAgIH1cbjwvc3R5bGU+IiwiPHNjcmlwdD5cbiAgICBpbXBvcnQge2ZseX0gZnJvbSAnc3ZlbHRlL3RyYW5zaXRpb24nXG5cbiAgICBsZXQgZGVmYXVsdENsYXNzZXMgPSAnJztcbiAgICBleHBvcnQgeyBkZWZhdWx0Q2xhc3NlcyBhcyBjbGFzcyB9O1xuICAgIGV4cG9ydCBsZXQgc3R5bGUgPSAnJztcbiAgICBleHBvcnQgbGV0IHNsaWRlSWQ7XG4gICAgZXhwb3J0IGxldCBhY3RpdmVTbGlkZTtcbiAgICBleHBvcnQgbGV0IGNlbnRlciA9IGZhbHNlO1xuICAgIGV4cG9ydCBsZXQgdHJhbnNpdGlvbkluID0ge1xuICAgICAgICBkdXJhdGlvbjogMjUwLFxuICAgICAgICB4OiAtMjAwXG4gICAgfTtcbiAgICBleHBvcnQgbGV0IHRyYW5zaXRpb25PdXQgPSB7XG4gICAgICAgIGR1cmF0aW9uOiAyNTAsXG4gICAgICAgIHg6IDIwMFxuICAgIH07XG4gICAgc2xpZGVJZCA9IHBhcnNlSW50KHNsaWRlSWQpO1xuXG48L3NjcmlwdD5cblxueyNpZiBzbGlkZUlkID09PSBhY3RpdmVTbGlkZX1cbiAgICA8ZGl2IGNsYXNzPXtgJHtkZWZhdWx0Q2xhc3Nlc30gc3ZlbHRlLWZwLWNvbnRlbnRgfSBzdHlsZT17c3R5bGV9IGluOmZseT17dHJhbnNpdGlvbklufSBvdXQ6Zmx5PXt0cmFuc2l0aW9uT3V0fSBjbGFzczpzdmVsdGUtZnAtZmxleGJveC1jZW50ZXI9e2NlbnRlcn0+XG4gICAgICAgIDxzbG90PlxuICAgICAgICA8L3Nsb3Q+XG4gICAgPC9kaXY+XG57L2lmfVxuXG48c3R5bGU+XG4gICAgLnN2ZWx0ZS1mcC1jb250ZW50IHtcbiAgICAgICAgaGVpZ2h0OiBpbmhlcml0O1xuICAgICAgICB3aWR0aDogaW5oZXJpdDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgfVxuICAgIC5zdmVsdGUtZnAtZmxleGJveC1jZW50ZXIge1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB9XG48L3N0eWxlPiIsImZ1bmN0aW9uIHRvVmFsKG1peCkge1xuXHR2YXIgaywgeSwgc3RyPScnO1xuXHRpZiAobWl4KSB7XG5cdFx0aWYgKHR5cGVvZiBtaXggPT09ICdvYmplY3QnKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShtaXgpKSB7XG5cdFx0XHRcdGZvciAoaz0wOyBrIDwgbWl4Lmxlbmd0aDsgaysrKSB7XG5cdFx0XHRcdFx0aWYgKG1peFtrXSAmJiAoeSA9IHRvVmFsKG1peFtrXSkpKSB7XG5cdFx0XHRcdFx0XHRzdHIgJiYgKHN0ciArPSAnICcpO1xuXHRcdFx0XHRcdFx0c3RyICs9IHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGsgaW4gbWl4KSB7XG5cdFx0XHRcdFx0aWYgKG1peFtrXSAmJiAoeSA9IHRvVmFsKGspKSkge1xuXHRcdFx0XHRcdFx0c3RyICYmIChzdHIgKz0gJyAnKTtcblx0XHRcdFx0XHRcdHN0ciArPSB5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIG1peCAhPT0gJ2Jvb2xlYW4nICYmICFtaXguY2FsbCkge1xuXHRcdFx0c3RyICYmIChzdHIgKz0gJyAnKTtcblx0XHRcdHN0ciArPSBtaXg7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcblx0dmFyIGk9MCwgeCwgc3RyPScnO1xuXHR3aGlsZSAoaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRpZiAoeCA9IHRvVmFsKGFyZ3VtZW50c1tpKytdKSkge1xuXHRcdFx0c3RyICYmIChzdHIgKz0gJyAnKTtcblx0XHRcdHN0ciArPSB4XG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdHI7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZ2V0T3JpZ2luYWxCb2R5UGFkZGluZygpIHtcbiAgY29uc3Qgc3R5bGUgPSB3aW5kb3cgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5LCBudWxsKSA6IHt9O1xuXG4gIHJldHVybiBwYXJzZUludCgoc3R5bGUgJiYgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgncGFkZGluZy1yaWdodCcpKSB8fCAwLCAxMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY3JvbGxiYXJXaWR0aCgpIHtcbiAgbGV0IHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAvLyAubW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUgc3R5bGVzIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL3Y0LjAuMC1hbHBoYS40L3Njc3MvX21vZGFsLnNjc3MjTDEwNi1MMTEzXG4gIHNjcm9sbERpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIHNjcm9sbERpdi5zdHlsZS50b3AgPSAnLTk5OTlweCc7XG4gIHNjcm9sbERpdi5zdHlsZS53aWR0aCA9ICc1MHB4JztcbiAgc2Nyb2xsRGl2LnN0eWxlLmhlaWdodCA9ICc1MHB4JztcbiAgc2Nyb2xsRGl2LnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxEaXYub2Zmc2V0V2lkdGggLSBzY3JvbGxEaXYuY2xpZW50V2lkdGg7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgcmV0dXJuIHNjcm9sbGJhcldpZHRoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0U2Nyb2xsYmFyV2lkdGgocGFkZGluZykge1xuICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHBhZGRpbmcgPiAwID8gYCR7cGFkZGluZ31weGAgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCb2R5T3ZlcmZsb3dpbmcoKSB7XG4gIHJldHVybiB3aW5kb3cgPyBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoIDwgd2luZG93LmlubmVyV2lkdGggOiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25kaXRpb25hbGx5VXBkYXRlU2Nyb2xsYmFyKCkge1xuICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IGdldFNjcm9sbGJhcldpZHRoKCk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL3Y0LjAuMC1hbHBoYS42L2pzL3NyYy9tb2RhbC5qcyNMNDMzXG4gIGNvbnN0IGZpeGVkQ29udGVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3AnXG4gIClbMF07XG4gIGNvbnN0IGJvZHlQYWRkaW5nID0gZml4ZWRDb250ZW50XG4gICAgPyBwYXJzZUludChmaXhlZENvbnRlbnQuc3R5bGUucGFkZGluZ1JpZ2h0IHx8IDAsIDEwKVxuICAgIDogMDtcblxuICBpZiAoaXNCb2R5T3ZlcmZsb3dpbmcoKSkge1xuICAgIHNldFNjcm9sbGJhcldpZHRoKGJvZHlQYWRkaW5nICsgc2Nyb2xsYmFyV2lkdGgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2x1bW5TaXplQ2xhc3MoaXNYcywgY29sV2lkdGgsIGNvbFNpemUpIHtcbiAgaWYgKGNvbFNpemUgPT09IHRydWUgfHwgY29sU2l6ZSA9PT0gJycpIHtcbiAgICByZXR1cm4gaXNYcyA/ICdjb2wnIDogYGNvbC0ke2NvbFdpZHRofWA7XG4gIH0gZWxzZSBpZiAoY29sU2l6ZSA9PT0gJ2F1dG8nKSB7XG4gICAgcmV0dXJuIGlzWHMgPyAnY29sLWF1dG8nIDogYGNvbC0ke2NvbFdpZHRofS1hdXRvYDtcbiAgfVxuXG4gIHJldHVybiBpc1hzID8gYGNvbC0ke2NvbFNpemV9YCA6IGBjb2wtJHtjb2xXaWR0aH0tJHtjb2xTaXplfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbigkJHByb3BzKSB7XG4gIC8vIFRPRE8gc3VwcG9ydCBrZXlzXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICBjb25zdCB7IGNoaWxkcmVuLCAkJHNjb3BlLCAkJHNsb3RzIH0gPSAkJHByb3BzO1xuICBjb25zdCByZXN0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKCQkcHJvcHMpKSB7XG4gICAgaWYgKGtleSAhPT0gXCJjaGlsZHJlblwiICYmIGtleSAhPT0gXCIkJHNjb3BlXCIgJiYga2V5ICE9PSBcIiQkc2xvdHNcIikge1xuICAgICAgcmVzdFtrZXldID0gJCRwcm9wc1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJyb3dzZXJFdmVudCh0YXJnZXQsIC4uLmFyZ3MpIHtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoLi4uYXJncyk7XG5cbiAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV3Q2Fyb3VzZWxBY3RpdmVJbmRleChkaXJlY3Rpb24sIGl0ZW1zLCBhY3RpdmVJbmRleCkge1xuICBpZiAoZGlyZWN0aW9uID09PSAncHJldicpIHtcbiAgICByZXR1cm4gYWN0aXZlSW5kZXggPT09IDAgPyBpdGVtcy5sZW5ndGggLSAxIDogYWN0aXZlSW5kZXggLSAxO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ25leHQnKSB7XG4gICAgcmV0dXJuIGFjdGl2ZUluZGV4ID09PSBpdGVtcy5sZW5ndGggLSAxID8gMCA6IGFjdGl2ZUluZGV4ICsgMTtcbiAgfVxufVxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG4gIGltcG9ydCB7IGNsZWFuIH0gZnJvbSAnLi91dGlscyc7XG5cbiAgbGV0IGNsYXNzTmFtZSA9ICcnO1xuICBleHBvcnQgeyBjbGFzc05hbWUgYXMgY2xhc3MgfTtcbiAgZXhwb3J0IGxldCBmbHVpZCA9IGZhbHNlO1xuICBleHBvcnQgbGV0IGlkID0gJyc7XG5cbiAgY29uc3QgcHJvcHMgPSBjbGVhbigkJHByb3BzKTtcblxuICAkOiBjbGFzc2VzID0gY2xzeChjbGFzc05hbWUsIGZsdWlkID8gJ2NvbnRhaW5lci1mbHVpZCcgOiAnY29udGFpbmVyJyk7XG48L3NjcmlwdD5cblxuPGRpdiB7Li4ucHJvcHN9IHtpZH0gY2xhc3M9e2NsYXNzZXN9PlxuICA8c2xvdCAvPlxuPC9kaXY+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbiAgaW1wb3J0IHsgY2xlYW4gfSBmcm9tICcuL3V0aWxzJztcblxuICBsZXQgY2xhc3NOYW1lID0gJyc7XG4gIGV4cG9ydCB7IGNsYXNzTmFtZSBhcyBjbGFzcyB9O1xuICBleHBvcnQgbGV0IG5vR3V0dGVycyA9IGZhbHNlO1xuICBleHBvcnQgbGV0IGZvcm0gPSBmYWxzZTtcbiAgZXhwb3J0IGxldCBpZCA9ICcnO1xuXG4gIGNvbnN0IHByb3BzID0gY2xlYW4oJCRwcm9wcyk7XG5cbiAgJDogY2xhc3NlcyA9IGNsc3goXG4gICAgY2xhc3NOYW1lLFxuICAgIG5vR3V0dGVycyA/ICduby1ndXR0ZXJzJyA6IG51bGwsXG4gICAgZm9ybSA/ICdmb3JtLXJvdycgOiAncm93J1xuICApO1xuPC9zY3JpcHQ+XG5cbjxkaXYgey4uLnByb3BzfSB7aWR9IGNsYXNzPXtjbGFzc2VzfT5cbiAgPHNsb3QgLz5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cbiAgaW1wb3J0IHsgY2xlYW4gfSBmcm9tICcuL3V0aWxzJztcbiAgaW1wb3J0IHsgZ2V0Q29sdW1uU2l6ZUNsYXNzLCBpc09iamVjdCB9IGZyb20gJy4vdXRpbHMnO1xuXG4gIGxldCBjbGFzc05hbWUgPSAnJztcbiAgZXhwb3J0IHsgY2xhc3NOYW1lIGFzIGNsYXNzIH07XG4gIGV4cG9ydCBsZXQgaWQgPSAnJztcblxuICBjb25zdCBwcm9wcyA9IGNsZWFuKCQkcHJvcHMpO1xuXG4gIGNvbnN0IGNvbENsYXNzZXMgPSBbXTtcbiAgY29uc3Qgd2lkdGhzID0gWyd4cycsICdzbScsICdtZCcsICdsZycsICd4bCddO1xuXG4gIHdpZHRocy5mb3JFYWNoKGNvbFdpZHRoID0+IHtcbiAgICBjb25zdCBjb2x1bW5Qcm9wID0gJCRwcm9wc1tjb2xXaWR0aF07XG4gICAgaWYgKCFjb2x1bW5Qcm9wICYmIGNvbHVtblByb3AgIT09ICcnKSB7XG4gICAgICByZXR1cm47IC8vbm8gdmFsdWUgZm9yIHRoaXMgd2lkdGhcbiAgICB9XG5cbiAgICBjb25zdCBpc1hzID0gY29sV2lkdGggPT09ICd4cyc7XG5cbiAgICBpZiAoaXNPYmplY3QoY29sdW1uUHJvcCkpIHtcbiAgICAgIGNvbnN0IGNvbFNpemVJbnRlcmZpeCA9IGlzWHMgPyAnLScgOiBgLSR7Y29sV2lkdGh9LWA7XG4gICAgICBjb25zdCBjb2xDbGFzcyA9IGdldENvbHVtblNpemVDbGFzcyhpc1hzLCBjb2xXaWR0aCwgY29sdW1uUHJvcC5zaXplKTtcblxuICAgICAgaWYgKGNvbHVtblByb3Auc2l6ZSB8fCBjb2x1bW5Qcm9wLnNpemUgPT09ICcnKSB7XG4gICAgICAgIGNvbENsYXNzZXMucHVzaChjb2xDbGFzcyk7XG4gICAgICB9XG4gICAgICBpZiAoY29sdW1uUHJvcC5wdXNoKSB7XG4gICAgICAgIGNvbENsYXNzZXMucHVzaChgcHVzaCR7Y29sU2l6ZUludGVyZml4fSR7Y29sdW1uUHJvcC5wdXNofWApO1xuICAgICAgfVxuICAgICAgaWYgKGNvbHVtblByb3AucHVsbCkge1xuICAgICAgICBjb2xDbGFzc2VzLnB1c2goYHB1bGwke2NvbFNpemVJbnRlcmZpeH0ke2NvbHVtblByb3AucHVsbH1gKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2x1bW5Qcm9wLm9mZnNldCkge1xuICAgICAgICBjb2xDbGFzc2VzLnB1c2goYG9mZnNldCR7Y29sU2l6ZUludGVyZml4fSR7Y29sdW1uUHJvcC5vZmZzZXR9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbENsYXNzZXMucHVzaChnZXRDb2x1bW5TaXplQ2xhc3MoaXNYcywgY29sV2lkdGgsIGNvbHVtblByb3ApKTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmICghY29sQ2xhc3Nlcy5sZW5ndGgpIHtcbiAgICBjb2xDbGFzc2VzLnB1c2goJ2NvbCcpO1xuICB9XG5cbiAgaWYgKGNsYXNzTmFtZSkge1xuICAgIGNvbENsYXNzZXMucHVzaChjbGFzc05hbWUpO1xuICB9XG48L3NjcmlwdD5cblxuPGRpdiB7Li4ucHJvcHN9IHtpZH0gY2xhc3M9e2NvbENsYXNzZXMuam9pbignICcpfT5cbiAgPHNsb3QgLz5cbjwvZGl2PlxuIiwiPHNjcmlwdD5cblx0aW1wb3J0IEZ1bGxwYWdlIGZyb20gJ3N2ZWx0ZS1mdWxscGFnZS9zcmMvRnVsbHBhZ2Uuc3ZlbHRlJztcblx0aW1wb3J0IEZ1bGxwYWdlU2VjdGlvbiBmcm9tICdzdmVsdGUtZnVsbHBhZ2Uvc3JjL0Z1bGxwYWdlU2VjdGlvbi5zdmVsdGUnXG5cdGltcG9ydCBGdWxscGFnZVNsaWRlIGZyb20gJ3N2ZWx0ZS1mdWxscGFnZS9zcmMvRnVsbHBhZ2VTbGlkZS5zdmVsdGUnO1xuXG5cdGltcG9ydCBDb250YWluZXIgZnJvbSAnc3ZlbHRlc3RyYXAvc3JjL0NvbnRhaW5lci5zdmVsdGUnO1xuXHRpbXBvcnQgUm93IGZyb20gJ3N2ZWx0ZXN0cmFwL3NyYy9Sb3cuc3ZlbHRlJztcblx0aW1wb3J0IENvbCBmcm9tICdzdmVsdGVzdHJhcC9zcmMvQ29sLnN2ZWx0ZSc7XG5cblx0Ly9JbmNsdWRlIGFsbCB0aXRsZXMgb2YgeW91ciBzZWN0aW9ucywgdGhpcyBpcyBhbHNvIHVzZWQgYXMgbnVtYmVyIHRoYXQgaW5kaWNhdGUgY291bnQgb2Ygc2VjdGlvbnNcblx0Y29uc3Qgc2VjdGlvbnMgPSBbXG5cdFx0J1N2ZWx0ZSBGdWxscGFnZScsXG5cdFx0J0ZlYXR1cmVzJyxcblx0XHQnR2l0SHViJyxcblx0XHQnRnV0dXJlJ1xuXHRdO1xuXHQvL0hhdmUgdG8gc2V0IHRvIDAgKG9yIHNlY3Rpb24geW91IHdpc2ggdG8gZGlzcGxheSBhcyBkZWZhdWx0KSwgb3RoZXJ3aXNlIHNlY3Rpb24gd2lsbCBub3QgZGlzcGxheVxuXHRsZXQgYWN0aXZlU2VjdGlvbiA9IDA7XG5cblx0Ly9TYW1lIG1lY2hhbmljcyBhcyBpbiBzZWN0aW9uc1xuXHRjb25zdCBzbGlkZXMgPSBbXG5cdFx0J3NsaWRlcycsXG5cdFx0J2Fycm93cycsXG5cdFx0J2RyYWcnLFxuXHRdO1xuXHQvL0Fsc28gaGFzIHRvIGJlIDAgb3Igc3BlY2lmaWMgaWQgb2Ygc2xpZGVcblx0bGV0IGFjdGl2ZVNsaWRlID0gMDtcbjwvc2NyaXB0PlxuXG48c3ZlbHRlOmhlYWQ+XG5cdDx0aXRsZT5TdmVsdGUtZnVsbHBhZ2U8L3RpdGxlPlxuPC9zdmVsdGU6aGVhZD5cblxuPEZ1bGxwYWdlIGJpbmQ6YWN0aXZlU2VjdGlvbiB7c2VjdGlvbnN9IGFycm93cyBkcmFnPlxuXHQ8RnVsbHBhZ2VTZWN0aW9uIHNlY3Rpb25JZD1cIjBcIiBiaW5kOmFjdGl2ZVNlY3Rpb24gY2VudGVyPlxuXHRcdDxDb250YWluZXIgY2xhc3M9XCJ0ZXh0LWNlbnRlclwiPlxuXHRcdFx0PFJvdz5cblx0XHRcdFx0PENvbD5cblx0XHRcdFx0XHQ8aDE+XG5cdFx0XHRcdFx0XHRTdmVsdGUgRnVsbHBhZ2Vcblx0XHRcdFx0XHQ8L2gxPlxuXHRcdFx0XHRcdDxwPlxuXHRcdFx0XHRcdFx0VGhpcyBwYWdlIGlzIG1hZGUgdXNpbmcgc3ZlbHRlLWZ1bGxwYWdlIGNvbXBvbmVudCwgdHJ5IHRvIHNjcm9sbCwgZHJhZyB3aXRoIG1vdXNlIG9yIHN3aXBlIHZlcnRpY2FsIHdpdGggZmluZ2VyLlxuXHRcdFx0XHRcdDwvcD5cblx0XHRcdFx0PC9Db2w+XG5cdFx0XHQ8L1Jvdz5cblx0XHQ8L0NvbnRhaW5lcj5cblx0PC9GdWxscGFnZVNlY3Rpb24+XG5cdDxGdWxscGFnZVNlY3Rpb24gc2VjdGlvbklkPVwiMVwiIGJpbmQ6YWN0aXZlU2VjdGlvbiBiaW5kOmFjdGl2ZVNsaWRlIHtzbGlkZXN9IGNsYXNzPVwiYmctaW5mb1wiIGFycm93cyBjZW50ZT5cblx0XHQ8RnVsbHBhZ2VTbGlkZSBzbGlkZUlkPVwiMFwiIGJpbmQ6YWN0aXZlU2xpZGUgY2VudGVyPlxuXHRcdFx0PGRpdj5hXG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L0Z1bGxwYWdlU2xpZGU+XG5cdFx0PEZ1bGxwYWdlU2xpZGUgc2xpZGVJZD1cIjFcIiBiaW5kOmFjdGl2ZVNsaWRlIGNsYXNzPVwiYmctZGFuZ2VyXCIgY2VudGVyPlxuXHRcdFx0PGRpdj5hXG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L0Z1bGxwYWdlU2xpZGU+XG5cdFx0PEZ1bGxwYWdlU2xpZGUgc2xpZGVJZD1cIjJcIiBiaW5kOmFjdGl2ZVNsaWRlIGNlbnRlcj5cblx0XHRcdDxkaXY+YVxuXHRcdFx0PC9kaXY+XG5cdFx0PC9GdWxscGFnZVNsaWRlPlxuXHQ8L0Z1bGxwYWdlU2VjdGlvbj5cblx0PEZ1bGxwYWdlU2VjdGlvbiBzZWN0aW9uSWQ9XCIyXCIgYmluZDphY3RpdmVTZWN0aW9uIGNlbnRlcj5cblx0XHQ8ZW1iZWQgc3JjPVwiXCIgdHlwZT1cIlwiPlxuXHQ8L0Z1bGxwYWdlU2VjdGlvbj5cblx0PEZ1bGxwYWdlU2VjdGlvbiBzZWN0aW9uSWQ9XCIzXCIgYmluZDphY3RpdmVTZWN0aW9uIGNsYXNzPVwiYmctd2FybmluZ1wiIGNlbnRlcj5cblx0XHQ8ZGl2PmFcblx0XHQ8L2Rpdj5cblx0PC9GdWxscGFnZVNlY3Rpb24+XG48L0Z1bGxwYWdlPlxuXG48c3R5bGU+XG5cbjwvc3R5bGU+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRHQWlJMEUsR0FBYSxrQkFBSyxHQUFLO0tBQUcsa0JBQWtCO0tBQUMsRUFBRTs7Ozs7Ozs7Ozs7Ozs7OztnSkFBL0MsR0FBYSxrQkFBSyxHQUFLO0tBQUcsa0JBQWtCO0tBQUMsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBRmxHLEdBQVE7Ozs7Z0NBQWIsTUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhFQU5WLEdBQU87cUNBQVMsR0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4QkFNVixHQUFROzs7OytCQUFiLE1BQUk7Ozs7Ozs7Ozs7Ozs7Ozs7b0NBQUosTUFBSTs7OztzQ0FOTSxHQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQUNILEtBQUs7Ozs7Y0F4SDNCLGNBQWMsR0FBRyxFQUFFO09BT1osS0FBSyxHQUFHLEVBQUU7T0FFVixhQUFhLEdBQUcsQ0FBQztPQUVqQixRQUFRO09BRVIsa0JBQWtCLEdBQUcsR0FBRztPQUV4QixNQUFNLEdBQUcsS0FBSztPQUVkLElBQUksR0FBRyxLQUFLO0tBRW5CLGlCQUFpQjtLQUNqQixrQkFBa0I7OztLQUdsQixPQUFPLE1BQU0sY0FBYzs7S0FDM0IsWUFBWSxHQUFHLENBQUM7OztLQUVoQixNQUFNLEdBQUcsSUFBSTs7O09BR1gsWUFBWSxHQUFJLEtBQUs7O01BRW5CLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTTs7TUFDckIsS0FBSyxPQUFPLElBQUksR0FBRyxPQUFPOzs7TUFFMUIsa0JBQWtCLEdBQUcsS0FBSyxH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
